<!DOCTYPE html>

<html>

<head>
  <title>Mancala</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <!-- Mobile support -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Material Design fonts -->
<!--   <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Roboto:300,400,500,700" type="text/css">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"> -->

  <!-- Bootstrap -->
  <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">

  <!-- Bootstrap Material Design -->
  <link href="bootstrap/dist/css/bootstrap-material-design.css" rel="stylesheet">
  <link href="bootstrap/dist/css/ripples.min.css" rel="stylesheet">

  <!-- Dropdown.js -->
  <link href="https://cdn.rawgit.com/FezVrasta/dropdown.js/master/jquery.dropdown.css" rel="stylesheet">

  <!-- Page style -->
  <link href="bootstrap/index.css" rel="stylesheet">

  <!-- jQuery -->
  <script type="text/javascript" src="javascript/jquery.js"></script>

  <!-- Twitter Bootstrap -->
	<script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

	<!-- Material Design for Bootstrap -->
	<script src="bootstrap/dist/js/material.js"></script>
	<script src="bootstrap/dist/js/ripples.min.js"></script>
	<script> 
	$.material.init();
	</script>

	<style>
		.panel{
			margin-top:10px;
			margin-bottom:10px;
		}
		.form-group .checkbox label, .form-group .radio label, .form-group label {
			font-size:1em;
			font-weight: 300;
			color: #333;
		}
		html {
			/*font-size: 20px;*/
			font-size: 62.5%; /* default is 16px */
		}
		body{
			font-size:1.8em;
			background-color: #F8F8F8 ;
		}
		.rules{
			font-size:0.8em;
		}
		.bord_spot_legend{
        	text-align: center;
    	}
    	.bord_spot{
        	/*font-size:2em;*/
        	text-align: center;
        	border: 3px solid black;
    	}
	    .bord_spot_span{
	        padding:5px;
	    }
	    .bord_spot div{
	        background-color: lightblue;
	        width: 100%;
	        height: 100%;
	        padding: 10px;
	        cursor: pointer;
	    }

	    /*New table design*/
	    #board{
	    	width:100%;
	    	text-align: center;
	    	
	    }
	    .board_player_info{
	    	padding:10px;
	    }
	    #board_holes{
	    	border: 3px solid black;
	    }
	    .board_hole_td{
	    	outline: 1.5px solid black;
	    }
	    .board_hole_td div{
	    	width: 100%;
	        height: 100%;
	        padding: 5px;
	        cursor: pointer;
	    }
	    .board_hole_store{
	    	border-right: 3px solid black;
	    	border-left: 3px solid black;
	    }
	    .board_hole_store div{
	    	padding-left: 5px;
	    	padding-right:5px;
	    }




	</style>

</head>
<body>

	<div class="container">
		<div class="row">
			<div class="col-sm-12">
				<div class="panel panel-primary">
					<div class="panel-heading" >About Mancala and the rules</div>
					<div class="panel-body">

						<p>The board game Mancala has many variations. For a full desicription of the game, please visit the <a href="https://en.wikipedia.org/wiki/Mancala">wikipedia</a> page. This implementation of the game is the most common one, also known as Kalah. These are the rules as listed on the Kalah specific <a href="https://en.wikipedia.org/wiki/Kalah">wikipedia</a> page:</p>
						<p>
							<ol>
							 	<li class = 'rules'>At the beginning of the game, three seeds are placed in each house. This is the traditional method.</li>
							 	<li class = 'rules'>Each player controls the six houses and their seeds on the player's side of the board. The player's score is the number of seeds in the store to their right.</li>
							  	<li class = 'rules'>Players take turns sowing their seeds. On a turn, the player removes all seeds from one of the houses under their control. Moving counter-clockwise, the player drops one seed in each house in turn, including the player's own store but not their opponent's.</li>
							  	<li class = 'rules'>If the last sown seed lands in the player's store, the player gets an additional move. There is no limit on the number of moves a player can make in their turn.</li>
							  	<li class = 'rules'>If the last sown seed lands in an empty house owned by the player, and the opposite house contains seeds, both the last seed and the opposite seeds are captured and placed into the player's store.</li>
							  	<li class = 'rules'>When one player no longer has any seeds in any of their houses, the game ends. The other player moves all remaining seeds to their store, and the player with the most seeds in their store wins.</li>
							</ol>
							It is possible for the game to end in a draw, with 18 seeds each.
						</p>
					</div>
				</div>
				<div class="panel panel-primary">

					<div class="panel-heading" >Select computer level</div>
					<div class="panel-body">
						<div class="form-group">
							<div class="radio radio-primary">
			                    <label>
			                      <input type="radio" name="optionsRadios" id="pc_mode_random" value="option1" checked="" onchange="pc_mode_selection(this.id)">
			               			<span class="circle"></span>
									<span class="check"></span>
			                      Amateur: Computer picks random moves
			                    </label>
			                </div>
			                <div class="radio radio-primary">
			                    <label>
			                      <input type="radio" name="optionsRadios" id="pc_mode_minimax_L1" value="option2" onchange="pc_mode_selection(this.id)">
			                      <span class="circle"></span>
			                      <span class="check"></span>
			                      Beginner: Minimax with alpha beta two levels deep
			                    </label>
			                </div>
			                <div class="radio radio-primary">
			                    <label>
			                      <input type="radio" name="optionsRadios" id="pc_mode_minimax_L2" value="option2" onchange="pc_mode_selection(this.id)">
			                      <span class="circle"></span>
			                      <span class="check"></span>
			                      Pretty hard: Minimax with alpha beta four levels deep
			                    </label>
			                </div>
			            </div>
					</div>
				</div>
				<div class="panel panel-primary">
					<div class="panel-heading" >Board</div>
					<div class="panel-body">
						<table id="board" style="width:100%">
							<tr>
								<td class="board_player_info" id="board_human_legend">Human</td>
							</tr>
							<tr>
								<td class="board_holes">
									<table id="board_holes" style="width:100%">
										<tr>
											<td class="board_hole_store" style="width:12.5%"><div id="A_store">0</div></td>
											<td class="board_two_vert_holes" style="width:12.5%">
												<table style="width:100%">
													<tr class = "board_hole_row">
														<td class="board_hole_td"><div id="A1">A1</div></td>
													</tr>
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="B1">B1</div></td>
													</tr>
												</table>
											</td>
											<td class="board_two_vert_holes" style="width:12.5%">
												<table  style="width:100%">
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="A2">A1</div></td>
													</tr>
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="B2">A1</div></td>
													</tr>
												</table>
											</td>
											<td class="board_two_vert_holes" style="width:12.5%">
												<table style="width:100%">
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="A3">A1</div></td>
													</tr>
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="B3">A1</div></td>
													</tr>
												</table>
											</td>						
											<td class="board_two_vert_holes" style="width:12.5%">
												<table style="width:100%">
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="A4">A1</div></td>
													</tr>
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="B4">A1</div></td>
													</tr>
												</table>
											</td>
											<td class="board_two_vert_holes" style="width:12.5%">
												<table style="width:100%">
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="A5">A1</div></td>
													</tr class = "board_hole_row">
													<tr>
														<td class = "board_hole_td"><div id="B5">A1</div></td>
													</tr>
												</table>
											</td>
											<td class="board_two_vert_holes" style="width:12.5%">
												<table style="width:100%">
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="A6">A1</div></td>
													</tr>
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="B6">A1</div></td>
													</tr>
												</table>
											</td>																													
											<td class="board_hole_store" style="width:12.5%"><div id="B_store">0</div></td>
										</tr>	
									</table>	
								</td>
							</tr>
							<tr>
								<td class="board_player_info" id="board_computer_legend">Computer</td>
							</tr>
						</table>
					</div>
				</div>				
			</div>
		</div>
	</div>
</body>

<script>
var computer_mode = 'pc_mode_random' 
var backup_board;

function pc_mode_selection(mode_selected){
	computer_mode = mode_selected
}

function Bord(){
	this.score = {"playerA": 0 , "playerB":0}
	
	this.field_names = ["A6", "A5", "A4", "A3", "A2", "A1", "A_store","B1", "B2", "B3", "B4", "B5", "B6", "B_store"]
	this.field_values = [4,4,4,4,4,4,0,4,4,4,4,4,4,0]
	
	this.player_to_move = "A"
	this.possible_moves = [];
	this.stones_to_distribute;
	this.last_stone_landed;
	this.next_computer_move;
	this.number_of_next_computer_moves_to_do = 0;
}

Bord.prototype.visualize_possible_moves = function(){
	// Add a border and event listener around the ones that are possible
	this.field_names.forEach(function(field_name, field_position){
		css_name = "#" + field_name
		if(this.possible_moves.indexOf(field_name) != -1){
			$('body').off('click',css_name)
			$('body').on('click', css_name,  field_name, correct_field_clicked)
			$(css_name).css('background-color', 'lightblue')
		}else{
			$('body').off('click',css_name)
			$('body').on('click', css_name,field_name,  false_button_clicked)
			$(css_name).css('background-color', 'transparent')
		}
	}, this)
}
Bord.prototype.visualize_best_move_computer = function(){
	temp_i = this.next_computer_move.length/2 - this.number_of_next_computer_moves_to_do
	// Event listeners zetten
	this.field_names.forEach(function(field_name, field_position){
		css_name = "#" + field_name
		if(this.next_computer_move.substring(temp_i*2 ,temp_i*2+ 2) == field_name){
			$('body').off('click',css_name)
			$('body').on('click', css_name,  field_name, correct_field_clicked)
			$(css_name).css('background-color', 'lightblue')
		}else{
			$('body').off('click',css_name)
			$('body').on('click', css_name,field_name,  false_button_clicked)
			$(css_name).css('background-color', 'transparent')
		}
	}, this)
}

function correct_field_clicked(click_event){
	field_name_clicked = click_event.data
	// Create back up of board
	backup_board = jQuery.extend(main_bord, {}, this)
	main_bord.move(field_name_clicked)
	main_bord.print_to_html();
	// Human or random pc is playing next
	// ---------------------------------
	if(main_bord.player_to_move == 'A' | computer_mode == 'pc_mode_random'){
		// Find next possible move
		main_bord.find_possible_moves('single');
		if(main_bord.player_to_move == 'A'){
			// Reset counter for computer player moves to do
			main_bord.number_of_next_computer_moves_to_do = 0
			// Let human pick one
			main_bord.visualize_possible_moves();

		}else if(computer_mode == 'pc_mode_random'){
			// Random selection by computer
			main_bord.number_of_next_computer_moves_to_do = 1
			main_bord.next_computer_move = main_bord.possible_moves[Math.floor(Math.random()*main_bord.possible_moves.length)];
			main_bord.visualize_best_move_computer();
		}
	// Minimax	
	// ---------------------------------
	}else if(main_bord.player_to_move == 'B' & (computer_mode == 'pc_mode_minimax_L1' | computer_mode == 'pc_mode_minimax_L2')){
		// Check if all the computer his moves are already excuted
		if(main_bord.number_of_next_computer_moves_to_do == 0){
			// Start minimax
			moves_generated = 0;
			if(computer_mode == 'pc_mode_minimax_L1'){
				main_bord.minimax(2, true)
				console.log('Moves generated: ' + moves_generated)
			}else if(computer_mode == 'pc_mode_minimax_L2'){
				console.log('Starting minimax level 4')
				main_bord.minimax(4, true)
				console.log('Moves generated: ' + moves_generated)
			}
			
			main_bord.next_computer_move = main_bord.minimax_tree['best_move']
			main_bord.number_of_next_computer_moves_to_do = main_bord.next_computer_move.length/2;
			
			console.log('Generated minimax tree')
			console.log(main_bord.minimax_tree)
			main_bord.visualize_best_move_computer();
		}else if(main_bord.number_of_next_computer_moves_to_do > 0 ){
			// Perform next move from minimax
			main_bord.number_of_next_computer_moves_to_do -=1
			//console.log('Number to do: ' + main_bord.number_of_next_computer_moves_to_do)
			main_bord.visualize_best_move_computer();
		}
		//console.log(main_bord.minimax_tree)
	}
	//main_bord.move(field_name_clicked, "real", "dont_check_for_double_move" )
}
var alpha;
var beta;
 
Bord.prototype.minimax = function(X_levels, maximizing_player, alpha, beta){
	
	// Find possible moves
	this.find_possible_moves('multiple')

	// Reset score tree
	this.minimax_tree = {}

	if(this.possible_moves.length == 0){
		// End of game
		console.log('End of game in minimax tree')
		var virtual_bord = jQuery.extend(true, {}, this)
		virtual_bord.allocate_stones_to_stores_end_of_game()
		this.minimax_tree['maximizer_score'] = virtual_bord.score['playerB']-virtual_bord.score['playerA']
		this.minimax_tree['minimizer_score'] = virtual_bord.score['playerB']-virtual_bord.score['playerA']
		return
	} 
	// Array sorteren om dan met alpha beta minder moves te moeten doen hopelijk
	this.possible_moves.sort(function(a, b){
  		return b.length - a.length;
	});
	// Initialize values
	this.minimax_tree['best_move'];
	this.minimax_tree['maximizer_score'] = -1000
	this.minimax_tree['minimizer_score'] = +1000
	// Level 1: simulate through all the options of the computer
	for(var i = 0; i < this.possible_moves.length; i++){
		//if(i>1) break
		// Create virtual board
		var virtual_bord = jQuery.extend(true, {}, this)
		// Move generation
		virtual_bord.tree_building_move(virtual_bord.possible_moves[i])
		
		// Do we have to go in deeper depth?
		if(X_levels == 1){
			var temp_score = virtual_bord.score['playerB']-virtual_bord.score['playerA']
			this.minimax_tree[this.possible_moves[i]] = temp_score

		}else if(X_levels == 2){
			virtual_bord.minimax(X_levels - 1 , false, this.minimax_tree['minimizer_score'] ,this.minimax_tree['maximizer_score'])
			this.minimax_tree[this.possible_moves[i]] = virtual_bord.minimax_tree
		}else if(X_levels ==3){
			virtual_bord.minimax(X_levels - 1 , true, this.minimax_tree['minimizer_score'] ,this.minimax_tree['maximizer_score'])
			this.minimax_tree[this.possible_moves[i]] = virtual_bord.minimax_tree
		}else if(X_levels ==4){
			virtual_bord.minimax(X_levels - 1 , false, this.minimax_tree['minimizer_score'] ,this.minimax_tree['maximizer_score'])
			this.minimax_tree[this.possible_moves[i]] = virtual_bord.minimax_tree
		}

		if(i==0){
			this.minimax_tree['best_move'] = this.possible_moves[i]
			if(X_levels == 1){
				this.minimax_tree['minimizer_score'] = temp_score
				this.minimax_tree['maximizer_score'] = temp_score
			}else{
				this.minimax_tree['maximizer_score'] = this.minimax_tree[this.possible_moves[i]]['maximizer_score']
				this.minimax_tree['minimizer_score'] = this.minimax_tree[this.possible_moves[i]]['minimizer_score']
			}
		}

		// MAXIMIZER
		if(i>0 & maximizing_player){
			
			if(this.minimax_tree[this.possible_moves[i]]['maximizer_score'] > this.minimax_tree['maximizer_score']){
					this.minimax_tree['maximizer_score'] = this.minimax_tree[this.possible_moves[i]]['maximizer_score']
					//this.minimax_tree['minimizer_score'] = this.minimax_tree[this.possible_moves[i]]['maximizer_score']
					this.minimax_tree['best_move'] = this.possible_moves[i]
			}
			// Here we check if the maximizer score is not greater than alpha, otherwize minimizer will never accept that 
			// the maximizer goes down this way
			if(this.minimax_tree['maximizer_score'] > alpha){
				break;
			}

		// MINIMIZER
		}else if (i>0 & !maximizing_player){
			// Depth is zero here, so only a score, not a tree
			if(X_levels == 1){
			// Player is minimizing
				if(temp_score < this.minimax_tree['minimizer_score']){
					this.minimax_tree['minimizer_score'] = temp_score
					//this.minimax_tree['maximizer_score'] = temp_score
					this.minimax_tree['best_move'] = this.possible_moves[i]
				}
			}else{
				if(this.minimax_tree[this.possible_moves[i]]['minimizer_score'] < this.minimax_tree['minimizer_score']){
					this.minimax_tree['minimizer_score'] = this.minimax_tree[this.possible_moves[i]]['minimizer_score']
					//this.minimax_tree['maximizer_score'] = this.minimax_tree[this.possible_moves[i]]['minimizer_score']
					this.minimax_tree['best_move'] = this.possible_moves[i]
				}
			}
			// Check if de minimizer score niet kleiner is dan beta, want dan mag je er mee stoppen!
			if(this.minimax_tree['minimizer_score'] < beta){
				break;
			}
		}
		//this.minimax_tree['moves'][this.possible_moves[i]] = temp_score_tree
		if(X_levels == 4){
			//console.log('this.minimax_tree')
			//console.log('-------------------')
			//console.log(this.minimax_tree)
			//console.log('-------------------')
		}
	}
}

function false_button_clicked(){
}

Bord.prototype.move = function(selected_field_code){
	console.log('Inside function move')
	// Decode selected field to position
	selected_field_position = this.field_names.indexOf(selected_field_code)
	selected_field_value = this.field_values[selected_field_position]
	// How many stones does he pick up and distribute
	this.stones_to_distribute = selected_field_value
	// Set initial selected fields to zero
	this.field_values[selected_field_position] = 0;
	// Distribute the rest of the stones
	this.distribute_the_stones();
	// Calculate scores
	this.remove_stones_conquered_and_update_score();
	// If the player lands in his own store, he can play again
	if(this.last_stone_landed.indexOf("store") != -1 & this.last_stone_landed.indexOf(this.player_to_move) != -1){
		
	}else{
		this.set_next_player_to_move();
		console.log('Player is changed: ' + this.player_to_move)
	}
}

Bord.prototype.print_to_html = function(){
	$("#A1").text(this.field_values[5])
	$("#A2").text(this.field_values[4])
	$("#A3").text(this.field_values[3])
	$("#A4").text(this.field_values[2])
	$("#A5").text(this.field_values[1])
	$("#A6").text(this.field_values[0])
	$("#B1").text(this.field_values[7])
	$("#B2").text(this.field_values[8])
	$("#B3").text(this.field_values[9])
	$("#B4").text(this.field_values[10])
	$("#B5").text(this.field_values[11])
	$("#B6").text(this.field_values[12])

	$("#A_store").text(this.field_values[6])
	$("#B_store").text(this.field_values[13])

	/*$("#board_human_legend").text("Score human: " + this.score['playerA'])
	$("#board_computer_legend").text("Score computer: " + this.score['playerB'])*/
}
Bord.prototype.find_possible_moves = function(single_or_multiple){
	
	// Create an array with the possible moves
	this.possible_moves = this.field_names
	// Filter out the stores
	this.possible_moves = this.possible_moves.filter(function(field_name){
		return field_name.indexOf("store") == -1
	}, this)

	// Filter, the current player should be in the field name
	this.possible_moves = this.possible_moves.filter(function(field_name){
		return field_name.indexOf(this.player_to_move) != -1
	}, this)
	// Filter, the number of stones in the possible fields should be bigger than zero
	this.possible_moves = this.possible_moves.filter(function(field_name){
		field_position = this.field_names.indexOf(field_name)
		return this.field_values[field_position] > 0
	}, this)

	// If no moves are left, end game. Only do this for real game (find single possible moves)
	if(this.possible_moves.length == 0 & single_or_multiple=='single'){
		//End of game
		this.allocate_stones_to_stores_end_of_game();	
		this.print_to_html();
		this.visualize_possible_moves();
		return
	}

	// Check if there is not a second move possible during tree building
	if(single_or_multiple == 'multiple'){
		var temp_double_moves = []
		// Loop over possible moves
		for(var i = 0; i<this.possible_moves.length; i++){
			// Create a virtual board and make a move
			var virtual_bord = jQuery.extend(true, {}, this)
			// Move the board, but do not switch player
			virtual_bord.move_and_check_for_doubles(this.possible_moves[i])
			if(virtual_bord.last_stone_landed.indexOf(this.player_to_move) != -1 & virtual_bord.last_stone_landed.indexOf("store") != -1){

				// Ok the computer has another move, the player can play again
				virtual_bord.find_possible_moves('multiple')
				// HIER ZIT EEN FOUT, BIJ HET ZOEKEN VAN DE DUBBELSE MOVES
				// This virtual move landed in the player his store, so add all the new moves in the array
				for(var j=0; j<virtual_bord.possible_moves.length; j++){
					temp_double_moves.push(this.possible_moves[i] + virtual_bord.possible_moves[j])
				}
				// Filter the double move out of the array, the paste of the two moves will come into his place
				this.possible_moves = this.possible_moves.filter(function(field_name){
					return field_name != this.possible_moves[i]
				}, this)
				// As you removed one field, do i-- as you enter the loop again
				i = i - 1;
				// Filter the empty spots out, because the player can not play there again
			}
		}
		// Join the new double moves				
		this.possible_moves = this.possible_moves.concat(temp_double_moves)	
	}
}

var debugging  = false;
var moves_generated;
Bord.prototype.tree_building_move = function(moves_to_simulate){
	// How many consequtive moves?
	number_of_consq_moves = moves_to_simulate.length / 2
	// Loop over them
	for(var i=0;i<number_of_consq_moves; i++){
		moves_generated += 1 // Counter for the moves generated
		// Cut move out of pasted move
		selected_field_code = moves_to_simulate.substring(i*2 , i*2 +2)
		// Decode selected field to position
		selected_field_position = this.field_names.indexOf(selected_field_code)
		selected_field_value = this.field_values[selected_field_position]
		// How many stones does he pick up and distribute
		this.stones_to_distribute = selected_field_value
		// Set initial selected fields to zero
		this.field_values[selected_field_position] = 0;
		// Distribute the rest of the stones
		this.distribute_the_stones();
		// Remember after the loop where the last stone landed, this is important to calculate the scores
		this.last_stone_landed = this.field_names[board_field_to_fill]
		// Calculate scores
		this.remove_stones_conquered_and_update_score();
	}
	// Ok all moves are simulated, switch player
	this.set_next_player_to_move();
	if(moves_to_simulate == 'A5A6'){
		debugging = true;
	}
}
// FUNCTION only ment to check during tree building if the last move did not fall into the store of the player
Bord.prototype.move_and_check_for_doubles = function(move_to_check){
	// Decode selected field to position
	selected_field_position = this.field_names.indexOf(move_to_check)
	selected_field_value = this.field_values[selected_field_position]
	// How many stones does he pick up and distribute
	this.stones_to_distribute = selected_field_value
	// Set initial selected fields to zero
	this.field_values[selected_field_position] = 0;
	// Distribute the rest of the stones
	this.distribute_the_stones();
	// Remember after the loop where the last stone landed, this is important to calculate the scores
	this.last_stone_landed = this.field_names[board_field_to_fill]
	// Calculate scores
	//this.remove_stones_conquered_and_update_score();
	// And find possible moves again, not switched player, so check moves of the same player
	//this.find_possible_moves();
	// End of game
	//if(this.possible_moves.length ==0){
		//End of game
	//	this.allocate_stones_to_stores_end_of_game();	
	//}
}

Bord.prototype.allocate_stones_to_stores_end_of_game = function(){
	var fields_to_allocate = this.field_names
	// Filter, not the stores
	fields_to_allocate = fields_to_allocate.filter(function(field_name){
		if(field_name.indexOf("store") == -1) return true
	},this)
	// Loop over the fields, give stones to the store of correct player and update the scores
	for(var i=0; i<fields_to_allocate.length;i++){
		// Field of player A or B?
		if(fields_to_allocate[i].indexOf("A") != -1){
			// Field of player A
			// Find position
			temp_position = this.field_names.indexOf(fields_to_allocate[i])
			// Update store and score
			this.field_values[6] += this.field_values[temp_position]
			this.score.playerA +=  this.field_values[temp_position]
			// Set stones to zero
			this.field_values[temp_position] = 0
		}else if(fields_to_allocate[i].indexOf("B") != -1){
			// Field of player B
			// Find position
			temp_position = this.field_names.indexOf(fields_to_allocate[i])
			// Update store and score
			this.field_values[13] += this.field_values[temp_position]
			this.score.playerB +=  this.field_values[temp_position]
			// Set stones to zero
			this.field_values[temp_position] = 0
		}
	}
}

Bord.prototype.build_X_level_moves = function(X_levels){
	// He already knows the next possible moves, which one should he pick?
	var score_tree = {}
	// If there are no moves left, the current score is the best one
	var best_score = this.score['playerB'] - this.score['playerA']
	var best_move;

	if(this.possible_moves.length == 0){
		// SO??? I don't think there is a problem, as he has already the scores
	} 
	// Level 1: simulate through all the options of the computer
	for(var i = 0; i < this.possible_moves.length; i++){
		score_tree[this.possible_moves[i]] = {}
		
		var virtual_bord = jQuery.extend(true, {}, this)
		// Move generation
		virtual_bord.tree_building_move(virtual_bord.possible_moves[i])
		// Register score
		var temp_score = virtual_bord.score['playerB']-virtual_bord.score['playerA']
		score_tree[this.possible_moves[i]]['score'] = temp_score
		// Level 2: for each option of computer, calculate scores of other player, is stored in another score tree
		// If there are no other moves left, the current score is also the minimizing score
		var temp_score_tree = {}
		var temp_minimizing_score = temp_score
		if( virtual_bord.possible_moves.length == 0){
			// SO??? I don't think there is a problem, as he has already the scores
		} 
		for(var j=0; j < virtual_bord.possible_moves.length; j++){
			// Create another virtual copy
			var virtual_bord_L2 = jQuery.extend(true, {}, virtual_bord)
			// Player A is playing again, so switch player
			virtual_bord_L2.player_to_move = "A"
			// Move generation
			virtual_bord_L2.tree_building_move(virtual_bord.possible_moves[j])
			// Keep track of score
			if(X_levels == 2){
				// Score is now just the difference between the scores of the two players
				var temp_score = virtual_bord_L2.score['playerB']-virtual_bord_L2.score['playerA']
				// Store in uniform object X_level_moves
				temp_score_tree[virtual_bord.possible_moves[j]] = {}
				temp_score_tree[virtual_bord.possible_moves[j]]['best_score'] = temp_score
			}else if(X_levels == 4){
				// He needs to generate again a 2 level tree, recursive
				temp_score_tree[virtual_bord.possible_moves[j]] = virtual_bord_L2.build_X_level_moves(2)
			}else if(X_levels == 6){
				// He needs to generate again a 2 level tree, recursive
				temp_score_tree[virtual_bord.possible_moves[j]] = virtual_bord_L2.build_X_level_moves(4)				
			}
			// Keep track of best score, Assuming player A goes for Minimizing
			if(j==0) {
				temp_minimizing_score = temp_score_tree[virtual_bord.possible_moves[j]]['best_score']
			}else{
				temp_minimizing_score = Math.min(temp_minimizing_score, temp_score_tree[virtual_bord.possible_moves[j]]['best_score'])
			}

			// Here you do alpha beta, if the value at this j-th in the i-th branch is already smaller that the value if the previous i-th
			// branch, the computer will never pick this i-th branch and no need to calculate the other j-branches
			if(i > 0 & temp_minimizing_score <= best_score){
				break;
			}
		}

		score_tree[this.possible_moves[i]]['score_tree'] = temp_score_tree
		score_tree[this.possible_moves[i]]['minimizing_score'] = temp_minimizing_score

		// Keep track of best score, When player B is maximizing
		if(i==0){
			best_move = this.possible_moves[0]
			best_score = temp_minimizing_score
		}else{
			if(temp_minimizing_score > best_score){
				best_score = temp_minimizing_score
				best_move = this.possible_moves[i]
			}
		}
	}

	// Resultaat goed formatten en returnen
	var X_level_moves = {}
	X_level_moves['best_move'] = best_move
	X_level_moves['best_score'] = best_score
	X_level_moves['score_tree'] = score_tree
	return X_level_moves
}

Bord.prototype.distribute_the_stones = function(){
	// Distribute the stones, i is the counter to loop over the holes
	var i = 1
	var stones_distributed = 0
	while (stones_distributed < this.stones_to_distribute) {
		// Look at next vield
		board_field_to_fill = selected_field_position + i;
		if(board_field_to_fill > 13)
	 		board_field_to_fill = board_field_to_fill - 14;
		// If it is a store, check if it is not the store of the opponent
		if(board_field_to_fill == 6 | board_field_to_fill == 13){
			if(this.field_names[board_field_to_fill].indexOf(this.player_to_move) == -1){
				// No stone is laid in the other hole, so don't substract a stone of the total stones to be distributed
				i++;
			}else{
				// Stone is laid in his own store
				this.field_values[board_field_to_fill] +=1 
				stones_distributed++;
				// Update the score by one, because the player scored by adding one to his store
				if(this.player_to_move == "A"){
				 	this.score["playerA"] += 1
				}else if(this.player_to_move == "B"){
				 	this.score["playerB"] += 1
				}			
				i++;
			}
		}else{
			//Normal hole
			this.field_values[board_field_to_fill] +=1 
			stones_distributed++;
			i++;
		}
	}
	// Remember after the loop where the last stone landed, this is important to calculate the scores
	this.last_stone_landed = this.field_names[board_field_to_fill]

}

Bord.prototype.remove_stones_conquered_and_update_score = function(){
	// First check, the last stone must be landed in the other player his array
	if(this.last_stone_landed.indexOf(this.player_to_move) == -1) return
	// Second check, the last stone landed must be the only stone in that field
	var last_stone_position = this.field_names.indexOf(this.last_stone_landed)
	if(this.field_values[last_stone_position] != 1) return
	// Last check, is it in a score?
	if(last_stone_position == 6 | last_stone_position == 13) return
	// All the checks passed, except one, there should be stones in the other side

	// Find the correct position to take stones of, take the stones and update the scores,
	// With filter mechanism, filter row current player, filter nummer of last stone landed (i.e.: A3 -> B3)
	field_captured_code = this.field_names
	field_captured_code = field_captured_code.filter(function(field_code, field_position){
		return field_code.indexOf(this.player_to_move) == -1
	}, this)
	field_captured_code = field_captured_code.filter(function(field_code, field_position){
		return field_code.indexOf(this.last_stone_landed[1]) > -1
	}, this)
	field_captured_code = field_captured_code[0]
	field_captured_position = this.field_names.indexOf(field_captured_code)

	// Last check, does the other side contains a stone? If not, no score, exit function
	if(this.field_values[field_captured_position] == 0) return

	// Update scores, one extra point for the last stone!
	if(this.player_to_move == "A"){
	 	this.score["playerA"] += this.field_values[field_captured_position] + 1
	 	this.field_values[6] += this.field_values[field_captured_position] + 1
	}else if(this.player_to_move == "B"){
	 	this.score["playerB"] += this.field_values[field_captured_position] + 1
	 	this.field_values[13] += this.field_values[field_captured_position] + 1
	}
	// Empty field 
	this.field_values[field_captured_position] = 0
	// Empty the field of the last stone
	this.field_values[last_stone_position] = 0
}
Bord.prototype.set_next_player_to_move = function(){
	if(this.player_to_move == "A"){
		this.player_to_move = "B"
	}else if(this.player_to_move == "B"){
	 	this.player_to_move = "A"
	}
}

Bord.prototype.print_end_score = function(){
	if(this.score.playerA > this.score.playerB){
		$("#board_human_legend").text('Player A won with ' + this.score.playerA + " seeds")
		$("#board_computer_legend").text('Player B lost with '+ this.score.playerB + " seeds")
	}else if(this.score.playerA < this.score.playerB){
		$("#board_computer_legend").text('Player B won with ' + this.score.playerB + " seeds")
		$("#board_human_legend").text('Player A lost with '+ this.score.playerA + " seeds")
	}else if(this.score.playerA == this.score.playerB){
		$("#board_computer_legend").text('Draw')
		$("#board_human_legend").text('Draw')
		return
	}
}

Bord.prototype.change_field_html = function(field_name){
	css_name = "#" + field_name
	$(css_name).text(this.field_values[this.field_names.indexOf(field_name)])
}

Bord.prototype.print_to_html_animated = function(last_button_clicked){
	
	// Remove all click options
	this.field_names.forEach(function(field_name, field_position){
		css_name = "#" + field_name
		$('body').off('click',css_name)
		$('body').on('click', css_name,field_name,  false_button_clicked)
		$(css_name).css('background-color', 'transparent')	
	}, this)

	// Loop with setInterval
	counter = 0
	loop_position = this.field_names.indexOf(last_button_clicked)
	var id = setInterval(function(){
		if(counter < this.field_values.length){
			this.change_field_html(this.field_names[loop_position])
			loop_position += 1
			if(loop_position > 13) loop_position = loop_position - 14
			counter += 1
		}else{
			clearInterval(id);
		}
	}.bind(this), 300);

	$("#board_human_legend").text("Score human: " + this.score['playerA'])
	$("#board_computer_legend").text("Score computer: " + this.score['playerB'])
}


// Initial game
main_bord = new Bord();
main_bord.print_to_html();
main_bord.find_possible_moves('real_move');
main_bord.visualize_possible_moves();


/*
Bord.prototype.move = function(selected_field_code, real_move_or_tree_building, check_for_double_move){

	// Decode selected field to position
	selected_field_position = this.field_names.indexOf(selected_field_code)
	selected_field_value = this.field_values[selected_field_position]
	// How many stones does he pick up and distribute
	this.stones_to_distribute = selected_field_value
	// Set initial selected fields to zero
	this.field_values[selected_field_position] = 0;
	// Distribute the rest of the stones
	this.distribute_the_stones();
	// Remember after the loop where the last stone landed, this is important to calculate the scores
	this.last_stone_landed = this.field_names[board_field_to_fill]
	// Calculate scores
	this.remove_stones_conquered_and_update_score();

	// If the player or computer lands in his own store, he can play again
	// ===================================================================
	if(this.last_stone_landed.indexOf("store") != -1 & this.last_stone_landed.indexOf(this.player_to_move) != -1){
		if(real_move_or_tree_building == "real" & this.player_to_move == 'A'){
			//Normal actions, just not switch player!
			this.print_to_html();
			this.find_possible_moves();
			if(this.possible_moves.length ==0){
				// End of game
				this.allocate_stones_to_stores_end_of_game();
				this.print_to_html()
				this.print_end_score()			
			}
			// If human, visualize all of his options
			this.visualize_possible_moves();	
			return	
		}
	}
	
	// Player did not land in his own store
	// ===================================================================
	if(real_move_or_tree_building == "real"){
		// Real move, so print everything and make board ready for next player
		this.print_to_html();
		this.set_next_player_to_move();
		this.find_possible_moves();
		//If possible moves array is empty, game is over
		if(this.possible_moves.length ==0){
			this.allocate_stones_to_stores_end_of_game();
			this.print_to_html()
			this.print_end_score()			
		}
		// If it is the computer, computer move, otherwise prepare board for human
		if(this.player_to_move == 'B'){
			//Computer move, is random mode selected?
			if(computer_mode == 'pc_mode_random'){
				// Generate random computer move
				this.next_computer_move = this.possible_moves[Math.floor(Math.random()*this.possible_moves.length)];
			}else if(computer_mode == 'pc_mode_minimax_L1'){
				// Minimax, so call function minimax that gives back best move
				this.next_computer_move = this.find_mini_max_move(2)
			}else if(computer_mode == 'pc_mode_minimax_L2'){
				// Minimax, so call function minimax that gives back best move
				this.next_computer_move = this.find_mini_max_move(4)
			}else if(computer_mode == 'pc_mode_minimax_L3'){
				// Minimax, so call function minimax that gives back best move
				this.next_computer_move = this.find_mini_max_move(6)
			}
			this.visualize_best_move_computer();
		}else{
			// Human player, highlight his options	
			this.visualize_possible_moves();
		}
	// From here onwards, not real moves, only building the trees
	}else if(real_move_or_tree_building == "tree_building"){
		if(check_for_double_move == 'check_for_double_move') {
			// He is checking for a double move, so don't switch player
		}else{
			// Switch player
			this.set_next_player_to_move();
		}
		// And find possible moves again
		this.find_possible_moves();
		// End of game
		if(this.possible_moves.length ==0){
			//End of game
			this.allocate_stones_to_stores_end_of_game();	
		}
	}
}
*/

/*Bord.prototype.human_or_random_computer_move = function(selected_field_code){
	console.log('human_or_random_computer_move')
	// Decode selected field to position
	selected_field_position = this.field_names.indexOf(selected_field_code)
	selected_field_value = this.field_values[selected_field_position]
	// How many stones does he pick up and distribute
	this.stones_to_distribute = selected_field_value
	// Set initial selected fields to zero
	this.field_values[selected_field_position] = 0;
	// Distribute the rest of the stones
	this.distribute_the_stones();
	// Calculate scores
	this.remove_stones_conquered_and_update_score();
	// If the player lands in his own store, he can play again
	if(this.last_stone_landed.indexOf("store") != -1 & this.last_stone_landed.indexOf(this.player_to_move) != -1){
		//Normal actions, just not switch player!
		this.print_to_html();
		this.find_possible_moves();
		if(this.possible_moves.length ==0){
			// End of game
			this.allocate_stones_to_stores_end_of_game();
			this.print_to_html()
			this.print_end_score()		
		}
		// If human, visualize all of his options
		if(this.player_to_move == 'A'){
			this.visualize_possible_moves();	
		}
		// If random computer move, pick one move
		if(this.player_to_move == 'B' & computer_mode == 'pc_mode_random'){
			// Pick a random move
			this.next_computer_move = this.possible_moves[Math.floor(Math.random()*this.possible_moves.length)];
			this.number_of_next_computer_moves_already_done = 0;
			this.visualize_best_move_computer();
		}
		return	
	}

	// Other player is up next
	this.print_to_html();
	this.set_next_player_to_move();

	// If random move, let the computer select
	if(this.player_to_move == 'B' & computer_mode == 'pc_mode_random'){
			this.find_possible_moves();
			if(this.possible_moves.length ==0){
				// End of game
				this.allocate_stones_to_stores_end_of_game();
				this.print_to_html()
				this.print_end_score()	
				return		
			}
			// Pick a random move
			this.next_computer_move = this.possible_moves[Math.floor(Math.random()*this.possible_moves.length)];
			this.number_of_next_computer_moves_already_done = 0;
			this.visualize_best_move_computer();
			return 
	}

	// If Human, visualize all possible moves
	if(this.player_to_move == 'A'){
		this.find_possible_moves();
		if(this.possible_moves.length ==0){
			// End of game
			this.allocate_stones_to_stores_end_of_game();
			this.print_to_html()
			this.print_end_score()	
			return		
		}
		this.visualize_possible_moves();	
	}


	// Smarter computer, so prepare next move;
	this.find_possible_moves("tree_building");
	//If possible moves array is empty, game is over
	if(this.possible_moves.length ==0){
		this.allocate_stones_to_stores_end_of_game();
		this.print_to_html()
		this.print_end_score()	
		return		
	}
	if(computer_mode == 'pc_mode_minimax_L1'){
		// Minimax, so call function minimax that gives back best move
		this.next_computer_move = this.find_mini_max_move(2)
	}else if(computer_mode == 'pc_mode_minimax_L2'){
		// Minimax, so call function minimax that gives back best move
		this.next_computer_move = this.find_mini_max_move(4)
	}else if(computer_mode == 'pc_mode_minimax_L3'){
		// Minimax, so call function minimax that gives back best move
		this.next_computer_move = this.find_mini_max_move(6)
	}
	// How many consequiteve moves will the computers do?
	// Hier zit bug als je op het einde van de game zit!!
	this.number_of_next_computer_moves = this.next_computer_move.length/2
	this.number_of_next_computer_moves_already_done = 0
	this.visualize_best_move_computer()
}
*/


</script>





</body>
</html>
