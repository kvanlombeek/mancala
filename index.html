<!DOCTYPE html>

<html>

<head>
  <title>Mancala</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <!-- Mobile support -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Material Design fonts -->
<!--   <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Roboto:300,400,500,700" type="text/css">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"> -->

  <!-- Bootstrap -->
  <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">

  <!-- Bootstrap Material Design -->
  <link href="bootstrap/dist/css/bootstrap-material-design.css" rel="stylesheet">
  <link href="bootstrap/dist/css/ripples.min.css" rel="stylesheet">

  <!-- Dropdown.js -->
  <link href="https://cdn.rawgit.com/FezVrasta/dropdown.js/master/jquery.dropdown.css" rel="stylesheet">

  <!-- Page style -->
  <link href="bootstrap/index.css" rel="stylesheet">

  <!-- jQuery -->
  <script type="text/javascript" src="javascript/jquery.js"></script>

  <!-- Twitter Bootstrap -->
	<script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

	<!-- Material Design for Bootstrap -->
	<script src="bootstrap/dist/js/material.js"></script>
	<script src="bootstrap/dist/js/ripples.min.js"></script>
	<script> 
	$.material.init();
	</script>

	<style>
<<<<<<< HEAD
/*		body{
			font-family: monospace;
		}*/
		.bord_spot_legend{
			text-align: center;
		}
		.bord_spot{
			font-size:200%;
			text-align: center;
			border: 3px solid black;
=======
		.panel{
			margin-top:10px;
			margin-bottom:10px;
		}
		.form-group .checkbox label, .form-group .radio label, .form-group label {
			font-size:1em;
			font-weight: 300;
			color: #333;
		}
		html {
			/*font-size: 20px;*/
			font-size: 62.5%; /* default is 16px */
>>>>>>> bootstrap_google_materialize
		}
		body{
			font-size:1.8em;
			background-color: #F8F8F8 ;
		}
<<<<<<< HEAD
<<<<<<< HEAD
		.bord_spot div{
			background-color: lightblue;
			width: 100%;
			height: 100%;
			padding: 10px;
		}
=======
=======
		.rules{
			font-size:0.8em;
		}
		.bord_spot_legend{
        	text-align: center;
    	}
    	.bord_spot{
        	/*font-size:2em;*/
        	text-align: center;
        	border: 3px solid black;
    	}
	    .bord_spot_span{
	        padding:5px;
	    }
	    .bord_spot div{
	        background-color: lightblue;
	        width: 100%;
	        height: 100%;
	        padding: 10px;
	        cursor: pointer;
	    }

	    /*New table design*/
	    #board{
	    	width:100%;
	    	text-align: center;
	    	
	    }
	    .board_player_info{
	    	padding:10px;
	    }
	    #board_holes{
	    	border: 3px solid black;
	    }
	    .board_hole_td{
	    	outline: 1.5px solid black;
	    }
	    .board_hole_td div{
	    	width: 100%;
	        height: 100%;
	        padding: 5px;
	        cursor: pointer;
	    }
	    .board_hole_store{
	    	border-right: 3px solid black;
	    	border-left: 3px solid black;
	    }
	    .board_hole_store div{
	    	padding-left: 5px;
	    	padding-right:5px;
	    }


>>>>>>> bootstrap_google_materialize


>>>>>>> bootstrap_google_materialize
	</style>

</head>
<body>

<<<<<<< HEAD
<div class="row">
	<div class="col s12 m12 l6">
		<div class="card">
			<div class="card-content">
				<span class="card-title" style="color:black;">Bord</span>
				<table id="bord" style="width:100%">
					<tr>
			    		<td class="bord_spot_legend">A1</td>
			    		<td class="bord_spot_legend">A2</td> 
			    		<td class="bord_spot_legend">A3</td>
			    		<td class="bord_spot_legend">A4</td>
			    		<td class="bord_spot_legend">A5</td>
			    		<td class="bord_spot_legend">A6</td>
		  			</tr>
		  			<tr>
			    		<td class="bord_spot"><div id="A1"><span class="bord_spot_span">0</span></div></td>
			    		<td class="bord_spot"><div id="A2"><span class="bord_spot_span">0</span></div></td> 
			    		<td class="bord_spot"><div id="A3"><span class="bord_spot_span">0</span></div></td>
			    		<td class="bord_spot"><div id="A4"><span class="bord_spot_span">0</span></div></td>
			    		<td class="bord_spot"><div id="A5"><span class="bord_spot_span">0</span></div></td>
			    		<td class="bord_spot"><div id="A6"><span class="bord_spot_span">0</span></div></td>
		  			</tr>
		  			<tr>
			    		<td class="bord_spot"><div id="B1"><span class="bord_spot_span">0</span></div></td>
			    		<td class="bord_spot"><div id="B2"><span class="bord_spot_span">0</span></div></td> 
			    		<td class="bord_spot"><div id="B3"><span class="bord_spot_span">0</span></div></td>
			    		<td class="bord_spot"><div id="B4"><span class="bord_spot_span">0</span></div></td>
			    		<td class="bord_spot"><div id="B5"><span class="bord_spot_span">0</span></div></td>
			    		<td class="bord_spot"><div id="B6"><span class="bord_spot_span">0</span></div></td>
		  			</tr>
		  			<tr>
			    		<td class="bord_spot_legend">B1</td>
			    		<td class="bord_spot_legend">B2</td> 
			    		<td class="bord_spot_legend">B3</td>
			    		<td class="bord_spot_legend">B4</td>
			    		<td class="bord_spot_legend">B5</td>
			    		<td class="bord_spot_legend">B6</td>
		  			</tr>
				</table>
			</div>
		</div>
	</div>
	<div class="col s12 m12 l6">
		<div class="card">
			<div class="card-content">
				<span class="card-title" style="color:black;">Gameplay</span>
				<p>
					Score player A: <span id="Score_playerA"></span><br>
					Score player B: <span id="Score_playerB"></span><br>
				</p>
				<br>
				<p>
					Latest computer move: <span id="latest_computer_move"></span>
				</p>
			</div>
		</div>
		<div class="card">
			<div class="card-content">
				<span class="card-title" style="color:black;">Computer mode</span>
				<p>
				  <form id="computer_mode_selection_form">
				    <p>
				      <input class="with-gap" name="group1" type="radio" id="pc_mode_random" checked="checked" onchange="pc_mode_selection(this.id)"/>
				      <label for="pc_mode_random" style="color:black">Computer picks random moves</label>
				    </p>
				    <p>
				      <input class="with-gap" name="group1" type="radio" id="pc_mode_stupid" disabled="disabled" onchange="pc_mode_selection(this.id)"/>
				      <label for="pc_mode_stupid">Computer lets you win</label>
				    </p>
				    <p>
				      <input class="with-gap" name="group1" type="radio" id="pc_mode_minimax" onchange="pc_mode_selection(this.id)"/>
				      <label for="pc_mode_minimax" style="color:black">Minimax level 1</label>
				    </p>
				  </form>
				</p>
=======
	<div class="container">
		<div class="row">
			<div class="col-sm-12">
				<div class="panel panel-primary">
					<div class="panel-heading" >About Mancala and the rules</div>
					<div class="panel-body">

						<p>The board game Mancala has many variations. For a full desicription of the game, please visit the <a href="https://en.wikipedia.org/wiki/Mancala">wikipedia</a> page. This implementation of the game is the most common one, also known as Kalah. These are the rules as listed on the Kalah specific <a href="https://en.wikipedia.org/wiki/Kalah">wikipedia</a> page:</p>
						<p>
							<ol>
							 	<li class = 'rules'>At the beginning of the game, three seeds are placed in each house. This is the traditional method.</li>
							 	<li class = 'rules'>Each player controls the six houses and their seeds on the player's side of the board. The player's score is the number of seeds in the store to their right.</li>
							  	<li class = 'rules'>Players take turns sowing their seeds. On a turn, the player removes all seeds from one of the houses under their control. Moving counter-clockwise, the player drops one seed in each house in turn, including the player's own store but not their opponent's.</li>
							  	<li class = 'rules'>If the last sown seed lands in the player's store, the player gets an additional move. There is no limit on the number of moves a player can make in their turn.</li>
							  	<li class = 'rules'>If the last sown seed lands in an empty house owned by the player, and the opposite house contains seeds, both the last seed and the opposite seeds are captured and placed into the player's store.</li>
							  	<li class = 'rules'>When one player no longer has any seeds in any of their houses, the game ends. The other player moves all remaining seeds to their store, and the player with the most seeds in their store wins.</li>
							</ol>
							It is possible for the game to end in a draw, with 18 seeds each.
						</p>
					</div>
				</div>
				<div class="panel panel-primary">

					<div class="panel-heading" >Select computer level</div>
					<div class="panel-body">
						<div class="form-group">
							<div class="radio radio-primary">
			                    <label>
			                      <input type="radio" name="optionsRadios" id="pc_mode_random" value="option1" checked="" onchange="pc_mode_selection(this.id)">
			               			<span class="circle"></span>
									<span class="check"></span>
			                      Amateur: Computer picks random moves
			                    </label>
			                </div>
			                <div class="radio radio-primary">
			                    <label>
			                      <input type="radio" name="optionsRadios" id="pc_mode_minimax_L1" value="option2" onchange="pc_mode_selection(this.id)">
			                      <span class="circle"></span>
			                      <span class="check"></span>
			                      Beginner: Minimax with alpha beta two levels deep
			                    </label>
			                </div>
			                <div class="radio radio-primary">
			                    <label>
			                      <input type="radio" name="optionsRadios" id="pc_mode_minimax_L2" value="option2" onchange="pc_mode_selection(this.id)">
			                      <span class="circle"></span>
			                      <span class="check"></span>
			                      Pretty hard: Minimax with alpha beta four levels deep
			                    </label>
			                </div>
			            </div>
					</div>
				</div>
				<div class="panel panel-primary">
					<div class="panel-heading" >Board</div>
					<div class="panel-body">
						<table id="board" style="width:100%">
							<tr>
								<td class="board_player_info" id="board_human_legend">Human</td>
							</tr>
							<tr>
								<td class="board_holes">
									<table id="board_holes" style="width:100%">
										<tr>
											<td class="board_hole_store" style="width:12.5%"><div id="A_store">0</div></td>
											<td class="board_two_vert_holes" style="width:12.5%">
												<table style="width:100%">
													<tr class = "board_hole_row">
														<td class="board_hole_td"><div id="A1">A1</div></td>
													</tr>
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="B1">B1</div></td>
													</tr>
												</table>
											</td>
											<td class="board_two_vert_holes" style="width:12.5%">
												<table  style="width:100%">
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="A2">A1</div></td>
													</tr>
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="B2">A1</div></td>
													</tr>
												</table>
											</td>
											<td class="board_two_vert_holes" style="width:12.5%">
												<table style="width:100%">
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="A3">A1</div></td>
													</tr>
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="B3">A1</div></td>
													</tr>
												</table>
											</td>						
											<td class="board_two_vert_holes" style="width:12.5%">
												<table style="width:100%">
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="A4">A1</div></td>
													</tr>
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="B4">A1</div></td>
													</tr>
												</table>
											</td>
											<td class="board_two_vert_holes" style="width:12.5%">
												<table style="width:100%">
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="A5">A1</div></td>
													</tr class = "board_hole_row">
													<tr>
														<td class = "board_hole_td"><div id="B5">A1</div></td>
													</tr>
												</table>
											</td>
											<td class="board_two_vert_holes" style="width:12.5%">
												<table style="width:100%">
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="A6">A1</div></td>
													</tr>
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="B6">A1</div></td>
													</tr>
												</table>
											</td>																													
											<td class="board_hole_store" style="width:12.5%"><div id="B_store">0</div></td>
										</tr>	
									</table>	
								</td>
							</tr>
							<tr>
								<td class="board_player_info" id="board_computer_legend">Computer</td>
							</tr>
						</table>
					</div>
<<<<<<< HEAD
				</div>
			</div>
			<div class="col-sm-12">
				<div class="panel panel-primary">
					<div class="panel-heading" >Scores</div>
					<div class="panel-body">	
						<p>
							Score player A: <span id="Score_playerA"></span><br>
							Score player B: <span id="Score_playerB"></span><br>
						</p>
						<br>
						<p>
							Latest computer move: <span id="latest_computer_move"></span>
						</p>
					</div>
				</div>
>>>>>>> bootstrap_google_materialize
=======
				</div>				
>>>>>>> bootstrap_google_materialize
			</div>
		</div>
	</div>
</body>

<script>
var computer_mode = 'pc_mode_minimax_L1' 

function pc_mode_selection(mode_selected){
	computer_mode = mode_selected
}

function Bord(){
	this.score = {"playerA": 0 , "playerB":0}
	
	this.field_names = ["A6", "A5", "A4", "A3", "A2", "A1", "A_store","B1", "B2", "B3", "B4", "B5", "B6", "B_store"]
	this.field_values = [4,4,4,4,4,4,0,4,4,4,4,4,4,0]
	
	this.player_to_move = "A"
	this.possible_moves = [];
	this.stones_to_distribute;
	this.last_stone_landed;
	this.next_computer_move;
}
Bord.prototype.find_possible_moves = function(real_move_or_tree_building){
	
	// Create an array with the possible moves
	this.possible_moves = this.field_names
	// Filter out the stores
	this.possible_moves = this.possible_moves.filter(function(field_name){
		return field_name.indexOf("store") == -1
	}, this)

	// Filter, the current player should be in the field name
	this.possible_moves = this.possible_moves.filter(function(field_name){
		return field_name.indexOf(this.player_to_move) != -1
	}, this)
	// Filter, the number of stones in the possible fields should be bigger than zero
	this.possible_moves = this.possible_moves.filter(function(field_name){
		field_position = this.field_names.indexOf(field_name)
		return this.field_values[field_position] > 0
	}, this)
	// Check if there is not a second move possible during tree building
	if(real_move_or_tree_building == 'tree_building'){
		var temp_double_moves = []
		// Loop over possible moves
		for(var i = 0; i<this.possible_moves.length; i++){
			// Create a virtual board and make a move
			var virtual_bord = jQuery.extend(true, {}, this)
			// Move the board, but do not switch player
			virtual_bord.move_and_check_for_doubles(this.possible_moves[i])
			if(virtual_bord.last_stone_landed.indexOf(this.player_to_move) != -1 & virtual_bord.last_stone_landed.indexOf("store") != -1){

				// Ok the computer has another move, the player can play again
				virtual_bord.find_possible_moves('tree_building')
				// HIER ZIT EEN FOUT, BIJ HET ZOEKEN VAN DE DUBBELSE MOVES
				// This virtual move landed in the player his store, so add all the new moves in the array
				for(var j=0; j<virtual_bord.possible_moves.length; j++){
					temp_double_moves.push(this.possible_moves[i] + virtual_bord.possible_moves[j])
				}
				// Filter the double move out of the array, the paste of the two moves will come into his place
				this.possible_moves = this.possible_moves.filter(function(field_name){
					return field_name != this.possible_moves[i]
				}, this)
				// As you removed one field, do i-- as you enter the loop again
				i = i - 1;
				// Filter the empty spots out, because the player can not play there again
			}
		}
		// Join the new double moves				
		this.possible_moves = this.possible_moves.concat(temp_double_moves)	
	}
}

Bord.prototype.visualize_possible_moves = function(){
	// Add a border and event listener around the ones that are possible
	this.field_names.forEach(function(field_name, field_position){
		css_name = "#" + field_name
		if(this.possible_moves.indexOf(field_name) != -1){
			$('body').off('click',css_name)
			$('body').on('click', css_name,  field_name, correct_button_clicked)
			$(css_name).css('background-color', 'lightblue')
		}else{
			$('body').off('click',css_name)
			$('body').on('click', css_name,field_name,  false_button_clicked)
			$(css_name).css('background-color', 'transparent')
		}
	}, this)
}
Bord.prototype.visualize_best_move_computer = function(){
	// Some foefelare to find the correct move to highlight in the sequence of moves:
	temp_i = this.number_of_next_computer_moves_already_done
	this.field_names.forEach(function(field_name, field_position){
		css_name = "#" + field_name
		if(this.next_computer_move.substring(temp_i*2 ,temp_i*2+ 2) == field_name){
			$('body').off('click',css_name)
			$('body').on('click', css_name,  field_name, correct_button_clicked)
			$(css_name).css('background-color', 'lightblue')
		}else{
			$('body').off('click',css_name)
			$('body').on('click', css_name,field_name,  false_button_clicked)
			$(css_name).css('background-color', 'transparent')
		}
	}, this)
}

function correct_button_clicked(click_event){
	field_name_clicked = click_event.data
	if(main_bord.player_to_move == 'A'){
		main_bord.human_move(field_name_clicked)
	}else{
		// Decode selected field to position
		selected_field_position = main_bord.field_names.indexOf(field_name_clicked)
		selected_field_value = main_bord.field_values[selected_field_position]
		// How many stones does he pick up and distribute
		main_bord.stones_to_distribute = selected_field_value
		// Set initial selected fields to zero
		main_bord.field_values[selected_field_position] = 0;
		// Distribute the rest of the stones
		main_bord.distribute_the_stones();
		// Calculate scores
		main_bord.remove_stones_conquered_and_update_score();
		// Print to HTML
		main_bord.print_to_html();
		// Keep track of the real moves he already did, add a move
		main_bord.number_of_next_computer_moves_already_done +=1
		if(main_bord.number_of_next_computer_moves_already_done == main_bord.number_of_next_computer_moves){
			// The moves are all done, so it is up to the human player again
			main_bord.set_next_player_to_move()
			// And find possible moves for him
			main_bord.find_possible_moves();
			if(main_bord.possible_moves.length ==0){
				// End of game
				main_bord.allocate_stones_to_stores_end_of_game();
				main_bord.print_to_html()
				main_bord.print_end_score()			
			}
			// Human is up next, so let him play again
			main_bord.visualize_possible_moves();	
			return
		}else{
			// Computer is still up to play next, so visualize computer again with next move
			main_bord.visualize_best_move_computer();
			return
		}
	}
	//main_bord.move(field_name_clicked, "real", "dont_check_for_double_move" )
}
function false_button_clicked(){
}


Bord.prototype.human_move = function(selected_field_code){
	// Decode selected field to position
	selected_field_position = this.field_names.indexOf(selected_field_code)
	selected_field_value = this.field_values[selected_field_position]
	// How many stones does he pick up and distribute
	this.stones_to_distribute = selected_field_value
	// Set initial selected fields to zero
	this.field_values[selected_field_position] = 0;
	// Distribute the rest of the stones
	this.distribute_the_stones();
	// Calculate scores
	this.remove_stones_conquered_and_update_score();
	// If the player lands in his own store, he can play again
	if(this.last_stone_landed.indexOf("store") != -1 & this.last_stone_landed.indexOf(this.player_to_move) != -1){
		//Normal actions, just not switch player!
		this.print_to_html();
		this.find_possible_moves();
		if(this.possible_moves.length ==0){
			// End of game
			this.allocate_stones_to_stores_end_of_game();
			this.print_to_html()
			this.print_end_score()			
		}
		// If human, visualize all of his options
		this.visualize_possible_moves();	
		return	
	}else{
		this.print_to_html();
		this.set_next_player_to_move();
		// Prepare next move;
		this.find_possible_moves("tree_building");
		//If possible moves array is empty, game is over
		if(this.possible_moves.length ==0){
			this.allocate_stones_to_stores_end_of_game();
			this.print_to_html()
			this.print_end_score()			
		}
		if(computer_mode == 'pc_mode_minimax_L1'){
			// Minimax, so call function minimax that gives back best move
			this.next_computer_move = this.find_mini_max_move(2)
		}else if(computer_mode == 'pc_mode_minimax_L2'){
			// Minimax, so call function minimax that gives back best move
			this.next_computer_move = this.find_mini_max_move(4)
		}else if(computer_mode == 'pc_mode_minimax_L3'){
			// Minimax, so call function minimax that gives back best move
			this.next_computer_move = this.find_mini_max_move(6)
		}
		// How many consequiteve moves will the computers do?
		this.number_of_next_computer_moves = this.next_computer_move.length/2
		this.number_of_next_computer_moves_already_done = 0
		this.visualize_best_move_computer()
	}
}
var debugging  = false;
Bord.prototype.tree_building_move = function(moves_to_simulate){
	// How many consequtive moves?
	number_of_consq_moves = moves_to_simulate.length / 2
	// Loop over them
	for(var i=0;i<number_of_consq_moves; i++){
		moves_generated += 1 // Counter for the moves generated

		// Cut move out of pasted move
		selected_field_code = moves_to_simulate.substring(i*2 , i*2 +2)
		// Decode selected field to position
		selected_field_position = this.field_names.indexOf(selected_field_code)
		selected_field_value = this.field_values[selected_field_position]
		// How many stones does he pick up and distribute
		this.stones_to_distribute = selected_field_value
		// Set initial selected fields to zero
		this.field_values[selected_field_position] = 0;
		// Distribute the rest of the stones
		this.distribute_the_stones();
		// Remember after the loop where the last stone landed, this is important to calculate the scores
		this.last_stone_landed = this.field_names[board_field_to_fill]
		// Calculate scores
		this.remove_stones_conquered_and_update_score();
	}
	// Ok all moves are simulated, switch player
	this.set_next_player_to_move();
	if(moves_to_simulate == 'A5A6'){
		debugging = true;
	}
	this.find_possible_moves("tree_building");
	// Check for end of game
	if(this.possible_moves.length ==0){
		this.allocate_stones_to_stores_end_of_game();	
	}
}
// FUNCTION only ment to check during tree building if the last move did not fall into the store of the player
Bord.prototype.move_and_check_for_doubles = function(move_to_check){
	// Decode selected field to position
	selected_field_position = this.field_names.indexOf(move_to_check)
	selected_field_value = this.field_values[selected_field_position]
	// How many stones does he pick up and distribute
	this.stones_to_distribute = selected_field_value
	// Set initial selected fields to zero
	this.field_values[selected_field_position] = 0;
	// Distribute the rest of the stones
	this.distribute_the_stones();
	// Remember after the loop where the last stone landed, this is important to calculate the scores
	this.last_stone_landed = this.field_names[board_field_to_fill]
	// Calculate scores
	//this.remove_stones_conquered_and_update_score();
	// And find possible moves again, not switched player, so check moves of the same player
	//this.find_possible_moves();
	// End of game
	//if(this.possible_moves.length ==0){
		//End of game
	//	this.allocate_stones_to_stores_end_of_game();	
	//}
}

Bord.prototype.move = function(selected_field_code, real_move_or_tree_building, check_for_double_move){

	// Decode selected field to position
	selected_field_position = this.field_names.indexOf(selected_field_code)
	selected_field_value = this.field_values[selected_field_position]
	// How many stones does he pick up and distribute
	this.stones_to_distribute = selected_field_value
	// Set initial selected fields to zero
	this.field_values[selected_field_position] = 0;
	// Distribute the rest of the stones
	this.distribute_the_stones();
	// Remember after the loop where the last stone landed, this is important to calculate the scores
	this.last_stone_landed = this.field_names[board_field_to_fill]
	// Calculate scores
	this.remove_stones_conquered_and_update_score();

	// If the player or computer lands in his own store, he can play again
	// ===================================================================
	if(this.last_stone_landed.indexOf("store") != -1 & this.last_stone_landed.indexOf(this.player_to_move) != -1){
		if(real_move_or_tree_building == "real" & this.player_to_move == 'A'){
			//Normal actions, just not switch player!
			this.print_to_html();
			this.find_possible_moves();
			if(this.possible_moves.length ==0){
				// End of game
				this.allocate_stones_to_stores_end_of_game();
				this.print_to_html()
				this.print_end_score()			
			}
			// If human, visualize all of his options
			this.visualize_possible_moves();	
			return	
		}
	}
	
	// Player did not land in his own store
	// ===================================================================
	if(real_move_or_tree_building == "real"){
		// Real move, so print everything and make board ready for next player
		this.print_to_html();
		this.set_next_player_to_move();
		this.find_possible_moves();
<<<<<<< HEAD
		// If it is the computer, computer move, otherwise prepare board for human
		if(this.player_to_move == 'B'){
			score_tree = this.build_2_level_tree_minimax
			console.log('Score tree is build')
			score_tree = console.log(score_tree)

			//Computer move, is random mode selected?
/*			if(computer_mode == 'pc_mode_random'){
=======
		//If possible moves array is empty, game is over
		if(this.possible_moves.length ==0){
			this.allocate_stones_to_stores_end_of_game();
			this.print_to_html()
			this.print_end_score()			
		}
		// If it is the computer, computer move, otherwise prepare board for human
		if(this.player_to_move == 'B'){
			//Computer move, is random mode selected?
			if(computer_mode == 'pc_mode_random'){
<<<<<<< HEAD
>>>>>>> bootstrap_google_materialize
				random_selected_field = this.possible_moves[Math.floor(Math.random()*this.possible_moves.length)];
				this.move(random_selected_field, "real");
				$('#latest_computer_move').text(random_selected_field)
			}else if(computer_mode == 'pc_mode_minimax'){
<<<<<<< HEAD
				best_move = this.find_mini_max_move()
				this.move(best_move, "real");
				$('#latest_computer_move').text(best_move)
			}*/

			//Debugging
			this.visualize_possible_moves();
=======
				// Minimax, so call function minimax that gives back random move
				best_move = this.find_mini_max_move()
				this.move(best_move, "real");
				$('#latest_computer_move').text(best_move)
			}

			//Debugging
			//this.visualize_possible_moves();
>>>>>>> bootstrap_google_materialize

=======
				// Generate random computer move
				this.next_computer_move = this.possible_moves[Math.floor(Math.random()*this.possible_moves.length)];
			}else if(computer_mode == 'pc_mode_minimax_L1'){
				// Minimax, so call function minimax that gives back best move
				this.next_computer_move = this.find_mini_max_move(2)
			}else if(computer_mode == 'pc_mode_minimax_L2'){
				// Minimax, so call function minimax that gives back best move
				this.next_computer_move = this.find_mini_max_move(4)
			}else if(computer_mode == 'pc_mode_minimax_L3'){
				// Minimax, so call function minimax that gives back best move
				this.next_computer_move = this.find_mini_max_move(6)
			}
			this.visualize_best_move_computer();
>>>>>>> bootstrap_google_materialize
		}else{
			// Human player, highlight his options	
			this.visualize_possible_moves();
		}
	// From here onwards, not real moves, only building the trees
	}else if(real_move_or_tree_building == "tree_building"){
		if(check_for_double_move == 'check_for_double_move') {
			// He is checking for a double move, so don't switch player
		}else{
			// Switch player
			this.set_next_player_to_move();
		}
		// And find possible moves again
		this.find_possible_moves();
		// End of game
		if(this.possible_moves.length ==0){
			//End of game
			this.allocate_stones_to_stores_end_of_game();	
		}
	}
}

<<<<<<< HEAD
<<<<<<< HEAD
// Build 2 level mini max tree, computer picks a move, player picks a move, all combinations of these two levels
Bord.prototype.build_2_level_tree_minimax = function(current_level){
	var score_tree = {}
		console.log('This possible moves, dit is gewoon de computer zijn mogelijkheden')
	console.log(this.possible_moves)
	for(var i = 0; i < this.possible_moves.length; i++){
		console.log('Inside loop, i = ' + i)
		score_tree[this.possible_moves[i]] = {}
		var virtual_bord = jQuery.extend(true, {}, this)
		virtual_bord.move(virtual_bord.possible_moves[i], "tree_building")
		console.log('Options if player B plays ' + this.possible_moves[i])
		console.log(virtual_bord.possible_moves)
		score_tree[this.possible_moves[i]]['score_L1'] = virtual_bord.score['playerB'] - virtual_bord.score['playerA'] 
		for(var j=0; j < virtual_bord.possible_moves.length; j++){
			var virtual_bord_L2 = jQuery.extend(true, {}, virtual_bord)
			virtual_bord_L2.move(virtual_bord.possible_moves[j], "tree_building")

			score_tree[this.possible_moves[i]][virtual_bord.possible_moves[j]]={'score_L2':virtual_bord_L2.score['playerB']-virtual_bord_L2.score['playerA']}
			console.log('A plays: ' + virtual_bord.possible_moves[j] + ' Score A: ' + virtual_bord_L2.score['playerA'] + ' Score B: ' + virtual_bord_L2.score['playerB'])
		}
	}
	console.log(score_tree)
	return score_tree;
}

/*function Score_tree(){
}

Score_tree.prototype.toString(){	
}*/


// Should get an argument levels deep
Bord.prototype.find_mini_max_move = function(){
	// He already knows the next possible moves, which one should he pick?
	console.log('Inside mini max')
	var score_tree = {}
	var max_score_L1;
	var best_move;

	for(var i = 0; i < this.possible_moves.length; i++){
		console.log('Inside loop, i = ' + i)
		score_tree[this.possible_moves[i]] = {}
		var virtual_bord = jQuery.extend(true, {}, this)
		virtual_bord.move(virtual_bord.possible_moves[i], "tree_building")
		score_tree[virtual_bord.possible_moves[i]]['score_L1'] = virtual_bord.score['playerB'] - virtual_bord.score['playerA'] 
		if(i == 0){
			max_score_L1 = score_tree[virtual_bord.possible_moves[i]]['score_L1'];
			best_move = virtual_bord.possible_moves[i];
		}else{
			if(score_tree[virtual_bord.possible_moves[i]]['score_L1'] > max_score_L1){
				max_score_L1 = score_tree[virtual_bord.possible_moves[i]]['score_L1'];
				best_move = virtual_bord.possible_moves[i];
			}
		}
	}
	console.log('This is the tree: ' + score_tree)
	console.log('He choose best move: ' + best_move)
=======
// Find best option in a tree
function find_best_move_in_tree_minimax(score_tree){
	console.log('Find best move now')
	for (var L1_move in score_tree) {
		console.log('Option L1 move: ' + L1_move + ' with score ' +  score_tree[L1_move]['score_L1'])
    	console.log(score_tree[L1_move]);
    	//for(var L2_move in score_tree[L1_move])
    	//	if()
=======
Bord.prototype.distribute_the_stones = function(){
	// Distribute the stones, i is the counter to loop over the holes
	var i = 1
	var stones_distributed = 0
	while (stones_distributed < this.stones_to_distribute) {
		// Look at next vield
		board_field_to_fill = selected_field_position + i;
		if(board_field_to_fill > 13)
	 		board_field_to_fill = board_field_to_fill - 14;
		// If it is a store, check if it is not the store of the opponent
		if(board_field_to_fill == 6 | board_field_to_fill == 13){
			if(this.field_names[board_field_to_fill].indexOf(this.player_to_move) == -1){
				// No stone is laid in the other hole, so don't substract a stone of the total stones to be distributed
				i++;
			}else{
				// Stone is laid in his own store
				this.field_values[board_field_to_fill] +=1 
				stones_distributed++;
				// Update the score by one, because the player scored by adding one to his store
				if(this.player_to_move == "A"){
				 	this.score["playerA"] += 1
				}else if(this.player_to_move == "B"){
				 	this.score["playerB"] += 1
				}			
				i++;
			}
		}else{
			//Normal hole
			this.field_values[board_field_to_fill] +=1 
			stones_distributed++;
			i++;
		}
>>>>>>> bootstrap_google_materialize
	}
	// Remember after the loop where the last stone landed, this is important to calculate the scores
	this.last_stone_landed = this.field_names[board_field_to_fill]

}

Bord.prototype.allocate_stones_to_stores_end_of_game = function(){
	var fields_to_allocate = this.field_names
	// Filter, not the stores
	fields_to_allocate = fields_to_allocate.filter(function(field_name){
		if(field_name.indexOf("store") == -1) return true
	},this)
	// Loop over the fields, give stones to the store of correct player and update the scores
	for(var i=0; i<fields_to_allocate.length;i++){
		// Field of player A or B?
		if(fields_to_allocate[i].indexOf("A") != -1){
			// Field of player A
			// Find position
			temp_position = this.field_names.indexOf(fields_to_allocate[i])
			// Update store and score
			this.field_values[6] += this.field_values[temp_position]
			this.score.playerA +=  this.field_values[temp_position]
			// Set stones to zero
			this.field_values[temp_position] = 0
		}else if(fields_to_allocate[i].indexOf("B") != -1){
			// Field of player B
			// Find position
			temp_position = this.field_names.indexOf(fields_to_allocate[i])
			// Update store and score
			this.field_values[13] += this.field_values[temp_position]
			this.score.playerB +=  this.field_values[temp_position]
			// Set stones to zero
			this.field_values[temp_position] = 0
		}
	}
}

Bord.prototype.build_X_level_moves = function(X_levels){
	// He already knows the next possible moves, which one should he pick?
	var score_tree = {}
	// If there are no moves left, the current score is the best one
	var best_score = this.score['playerB'] - this.score['playerA']
	var best_move;

	if(this.possible_moves.length == 0){
		// SO??? I don't think there is a problem, as he has already the scores
	} 
	// Level 1: simulate through all the options of the computer
	for(var i = 0; i < this.possible_moves.length; i++){
		score_tree[this.possible_moves[i]] = {}
		
		var virtual_bord = jQuery.extend(true, {}, this)
		// Move generation
		virtual_bord.tree_building_move(virtual_bord.possible_moves[i])
		// Register score
		var temp_score = virtual_bord.score['playerB']-virtual_bord.score['playerA']
		score_tree[this.possible_moves[i]]['score'] = temp_score
		// Level 2: for each option of computer, calculate scores of other player, is stored in another score tree
		// If there are no other moves left, the current score is also the minimizing score
		var temp_score_tree = {}
		var temp_minimizing_score = temp_score
		if( virtual_bord.possible_moves.length == 0){
			// SO??? I don't think there is a problem, as he has already the scores
		} 
		for(var j=0; j < virtual_bord.possible_moves.length; j++){
			// Create another virtual copy
			var virtual_bord_L2 = jQuery.extend(true, {}, virtual_bord)
			// Player A is playing again, so switch player
			virtual_bord_L2.player_to_move = "A"
			// Move generation
			virtual_bord_L2.tree_building_move(virtual_bord.possible_moves[j])
			// Keep track of score
			if(X_levels == 2){
				// Score is now just the difference between the scores of the two players
				var temp_score = virtual_bord_L2.score['playerB']-virtual_bord_L2.score['playerA']
				// Store in uniform object X_level_moves
				temp_score_tree[virtual_bord.possible_moves[j]] = {}
				temp_score_tree[virtual_bord.possible_moves[j]]['best_score'] = temp_score
			}else if(X_levels == 4){
				// He needs to generate again a 2 level tree, recursive
				temp_score_tree[virtual_bord.possible_moves[j]] = virtual_bord_L2.build_X_level_moves(2)
			}else if(X_levels == 6){
				// He needs to generate again a 2 level tree, recursive
				temp_score_tree[virtual_bord.possible_moves[j]] = virtual_bord_L2.build_X_level_moves(4)				
			}
			// Keep track of best score, Assuming player A goes for Minimizing
			if(j==0) {
				temp_minimizing_score = temp_score_tree[virtual_bord.possible_moves[j]]['best_score']
			}else{
				temp_minimizing_score = Math.min(temp_minimizing_score, temp_score_tree[virtual_bord.possible_moves[j]]['best_score'])
			}

			// Here you do alpha beta, if the value at this j-th in the i-th branch is already smaller that the value if the previous i-th
			// branch, the computer will never pick this i-th branch and no need to calculate the other j-branches
			if(i > 0 & temp_minimizing_score <= best_score){
				break;
			}
		}

		score_tree[this.possible_moves[i]]['score_tree'] = temp_score_tree
		score_tree[this.possible_moves[i]]['minimizing_score'] = temp_minimizing_score

		// Keep track of best score, When player B is maximizing
		if(i==0){
			best_move = this.possible_moves[0]
			best_score = temp_minimizing_score
		}else{
			if(temp_minimizing_score > best_score){
				best_score = temp_minimizing_score
				best_move = this.possible_moves[i]
			}
		}
	}
<<<<<<< HEAD
	console.log(score_tree)
	console.log(best_move)
>>>>>>> bootstrap_google_materialize
=======

	// Resultaat goed formatten en returnen
	var X_level_moves = {}
	X_level_moves['best_move'] = best_move
	X_level_moves['best_score'] = best_score
	X_level_moves['score_tree'] = score_tree
	return X_level_moves
}

var moves_generated;
// Should get an argument levels deep
Bord.prototype.find_mini_max_move = function(levels){
	moves_generated = 0;
	X_level_moves = this.build_X_level_moves(levels)
	best_move = X_level_moves['best_move']
>>>>>>> bootstrap_google_materialize
	return best_move
}



Bord.prototype.remove_stones_conquered_and_update_score = function(){
	// First check, the last stone must be landed in the other player his array
	if(this.last_stone_landed.indexOf(this.player_to_move) == -1) return
	// Second check, the last stone landed must be the only stone in that field
	var last_stone_position = this.field_names.indexOf(this.last_stone_landed)
	if(this.field_values[last_stone_position] != 1) return
	// Last check, is it in a score?
	if(last_stone_position == 6 | last_stone_position == 13) return
	// All the checks passed, except one, there should be stones in the other side

	// Find the correct position to take stones of, take the stones and update the scores,
	// With filter mechanism, filter row current player, filter nummer of last stone landed (i.e.: A3 -> B3)
	field_captured_code = this.field_names
	field_captured_code = field_captured_code.filter(function(field_code, field_position){
		return field_code.indexOf(this.player_to_move) == -1
	}, this)
	field_captured_code = field_captured_code.filter(function(field_code, field_position){
		return field_code.indexOf(this.last_stone_landed[1]) > -1
	}, this)
	field_captured_code = field_captured_code[0]
	field_captured_position = this.field_names.indexOf(field_captured_code)

	// Last check, does the other side contains a stone? If not, no score, exit function
	if(this.field_values[field_captured_position] == 0) return

	// Update scores, one extra point for the last stone!
	if(this.player_to_move == "A"){
	 	this.score["playerA"] += this.field_values[field_captured_position] + 1
	 	this.field_values[6] += this.field_values[field_captured_position] + 1
	}else if(this.player_to_move == "B"){
	 	this.score["playerB"] += this.field_values[field_captured_position] + 1
	 	this.field_values[13] += this.field_values[field_captured_position] + 1
	}
	// Empty field 
	this.field_values[field_captured_position] = 0
	// Empty the field of the last stone
	this.field_values[last_stone_position] = 0
}
Bord.prototype.set_next_player_to_move = function(){
	if(this.player_to_move == "A"){
		this.player_to_move = "B"
	}else if(this.player_to_move == "B"){
	 	this.player_to_move = "A"
	}
}
Bord.prototype.print_to_html = function(){
	$("#A1").text(this.field_values[5])
	$("#A2").text(this.field_values[4])
	$("#A3").text(this.field_values[3])
	$("#A4").text(this.field_values[2])
	$("#A5").text(this.field_values[1])
	$("#A6").text(this.field_values[0])
	$("#B1").text(this.field_values[7])
	$("#B2").text(this.field_values[8])
	$("#B3").text(this.field_values[9])
	$("#B4").text(this.field_values[10])
	$("#B5").text(this.field_values[11])
	$("#B6").text(this.field_values[12])

	$("#A_store").text(this.field_values[6])
	$("#B_store").text(this.field_values[13])

	$("#board_human_legend").text("Score human: " + this.score['playerA'])
	$("#board_computer_legend").text("Score computer: " + this.score['playerB'])
}
Bord.prototype.print_end_score = function(){
	if(this.score.playerA > this.score.playerB){
		$("#board_human_legend").text('Player A won with ' + this.score.playerA + " seeds")
		$("#board_computer_legend").text('Player B lost with '+ this.score.playerB + " seeds")
	}else if(this.score.playerA < this.score.playerB){
		$("#board_computer_legend").text('Player B won with ' + this.score.playerB + " seeds")
		$("#board_human_legend").text('Player A lost with '+ this.score.playerA + " seeds")
	}else if(this.score.playerA == this.score.playerB){
		$("#board_computer_legend").text('Draw')
		$("#board_human_legend").text('Draw')
		return
	}
}

Bord.prototype.change_field_html = function(field_name){
	css_name = "#" + field_name
	$(css_name).text(this.field_values[this.field_names.indexOf(field_name)])
}

Bord.prototype.print_to_html_animated = function(last_button_clicked){
	
	// Remove all click options
	this.field_names.forEach(function(field_name, field_position){
		css_name = "#" + field_name
		$('body').off('click',css_name)
		$('body').on('click', css_name,field_name,  false_button_clicked)
		$(css_name).css('background-color', 'transparent')	
	}, this)

	// Loop with setInterval
	counter = 0
	loop_position = this.field_names.indexOf(last_button_clicked)
	var id = setInterval(function(){
		if(counter < this.field_values.length){
			this.change_field_html(this.field_names[loop_position])
			loop_position += 1
			if(loop_position > 13) loop_position = loop_position - 14
			counter += 1
		}else{
			clearInterval(id);
		}
	}.bind(this), 300);

	// Old while loop
	// loop_position = this.field_values.indexOf(last_button_clicked)
	// while(counter < this.field_values.length){
	// 	console.log('Is he looping')
	// 	// Loop over buttons and update the score, starting from the one that was last clicked
	// 	css_name = "#" + this.field_names[loop_position]
	// 	$(css_name).text(this.field_values[loop_position])
	// 	loop_position += 1
	// 	if(loop_position > 13){
	// 		loop_position - 14
	// 	}
	// 	counter +=1
	// }

	$("#board_human_legend").text("Score human: " + this.score['playerA'])
	$("#board_computer_legend").text("Score computer: " + this.score['playerB'])
}

main_bord = new Bord();
main_bord.print_to_html();
main_bord.find_possible_moves('real_move');
main_bord.visualize_possible_moves();






</script>

<<<<<<< HEAD
=======




</body>
>>>>>>> bootstrap_google_materialize
</html>
