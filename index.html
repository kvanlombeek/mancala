<!DOCTYPE html>

<html>

<head>
  <title>Mancala</title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <!-- Mobile support -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Material Design fonts -->
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Roboto:300,400,500,700" type="text/css">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

  <!-- Bootstrap -->
  <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet">

  <!-- Bootstrap Material Design -->
  <link href="bootstrap/dist/css/bootstrap-material-design.css" rel="stylesheet">
  <link href="bootstrap/dist/css/ripples.min.css" rel="stylesheet">

  <!-- Dropdown.js -->
  <link href="https://cdn.rawgit.com/FezVrasta/dropdown.js/master/jquery.dropdown.css" rel="stylesheet">

  <!-- Page style -->
  <link href="bootstrap/index.css" rel="stylesheet">

  <!-- jQuery -->
  <script type="text/javascript" src="javascript/jquery.js"></script>

  <!-- Twitter Bootstrap -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.6/js/bootstrap.min.js"></script>

	<!-- Material Design for Bootstrap -->
	<script src="bootstrap/dist/js/material.js"></script>
	<script src="bootstrap/dist/js/ripples.min.js"></script>
	<script> 
	$.material.init();
	</script>

	<style>
		.panel{
			margin-top:10px;
			margin-bottom:10px;
		}
		.form-group .checkbox label, .form-group .radio label, .form-group label {
			font-size:1em;
			font-weight: 300;
			color: #333;
		}
		html {
			/*font-size: 20px;*/
			font-size: 62.5%; /* default is 16px */
		}
		body{
			font-size:1.8em;
			background-color: #F8F8F8 ;
		}
		.bord_spot_legend{
        	text-align: center;
    	}
    	.bord_spot{
        	/*font-size:2em;*/
        	text-align: center;
        	border: 3px solid black;
    	}
	    .bord_spot_span{
	        padding:5px;
	    }
	    .bord_spot div{
	        background-color: lightblue;
	        width: 100%;
	        height: 100%;
	        padding: 10px;
	        cursor: pointer;
	    }

	    /*New table design*/
	    #board{
	    	width:100%;
	    	text-align: center;
	    	
	    }
	    .board_player_info{
	    	padding:10px;
	    }
	    #board_holes{
	    	border: 3px solid black;
	    }
	    .board_hole_td{
	    	outline: 1.5px solid black;
	    }
	    .board_hole_td div{
	    	width: 100%;
	        height: 100%;
	        padding: 5px;
	        cursor: pointer;
	    }
	    .board_hole_store{
	    	border-right: 3px solid black;
	    	border-left: 3px solid black;
	    }
	    .board_hole_store div{
	    	padding-left: 5px;
	    	padding-right:5px;
	    }




	</style>

</head>
<body>

	<div class="container">
		<div class="row">
			<div class="col-sm-12">
				<div class="panel panel-primary">
					<div class="panel-heading" >About Mancala and the rules</div>
					<div class="panel-body">

						<p>The board game Mancala has many variations. For a full desicription of the game, please visit the <a href="https://en.wikipedia.org/wiki/Mancala">wiki</a> page. This implementation of the game is the easiest and most common one.</p>
						<p>You are player A and the computer is player B. The numbers represent the amount of stones in a hole. At the beginning of your turn,  select one of the holes with stones at your side of the board. These stones will be seed. The seeding stones are dropped one-by-one into the subsequent holes, following a counter-clockwise rotation around the board. If the last of the seeding stones ends into an empty hole of the opponent, you capture the stones that are present in the opposite hole on your side. </p>
						<p>When a player is out of stones or no other moves are possible, the player with most stones wins the game.</p>
					</div>
				</div>
				<div class="panel panel-primary">

					<div class="panel-heading" >Select computer level</div>
					<div class="panel-body">
						<div class="form-group">
							<div class="radio radio-primary">
			                    <label>
			                      <input type="radio" name="optionsRadios" id="pc_mode_random" value="option1" checked="" onchange="pc_mode_selection(this.id)">
			               			<span class="circle"></span>
									<span class="check"></span>
			                      Amateur: Computer picks random moves
			                    </label>
			                </div>
			                <div class="radio radio-primary">
			                    <label>
			                      <input type="radio" name="optionsRadios" id="pc_mode_minimax_L1" value="option2" onchange="pc_mode_selection(this.id)">
			                      <span class="circle"></span>
			                      <span class="check"></span>
			                      Beginner: Minimax two levels deep
			                    </label>
			                </div>
			                <div class="radio radio-primary">
			                    <label>
			                      <input type="radio" name="optionsRadios" id="pc_mode_minimax_L2" value="option2" onchange="pc_mode_selection(this.id)">
			                      <span class="circle"></span>
			                      <span class="check"></span>
			                      Pretty hard: Minimax four levels deep
			                    </label>
			                </div>
			                <div class="radio radio-primary">
			                    <label>
			                      <input type="radio" name="optionsRadios" id="pc_mode_minimax_L3" value="option2" onchange="pc_mode_selection(this.id)">
			                      <span class="circle"></span>
			                      <span class="check"></span>
			                      Expert: Minimax six levels deep
			                    </label>
			                </div>
			            </div>
					</div>
				</div>
				<div class="panel panel-primary">
					<div class="panel-heading" >Board</div>
					<div class="panel-body">
						<table id="board" style="width:100%">
							<tr>
								<td class="board_player_info" id="board_human_legend">Human</td>
							</tr>
							<tr>
								<td class="board_holes">
									<table id="board_holes" style="width:100%">
										<tr>
											<td class="board_hole_store"><div id="A_store">0</div></td>
											<td class="board_two_vert_holes">
												<table style="width:100%">
													<tr class = "board_hole_row">
														<td class="board_hole_td"><div id="A1">A1</div></td>
													</tr>
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="B1">B1</div></td>
													</tr>
												</table>
											</td>
											<td class="board_two_vert_holes">
												<table  style="width:100%">
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="A2">A1</div></td>
													</tr>
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="B2">A1</div></td>
													</tr>
												</table>
											</td>
											<td class="board_two_vert_holes">
												<table style="width:100%">
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="A3">A1</div></td>
													</tr>
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="B3">A1</div></td>
													</tr>
												</table>
											</td>						
											<td class="board_two_vert_holes">
												<table style="width:100%">
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="A4">A1</div></td>
													</tr>
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="B4">A1</div></td>
													</tr>
												</table>
											</td>
											<td class="board_two_vert_holes">
												<table style="width:100%">
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="A5">A1</div></td>
													</tr class = "board_hole_row">
													<tr>
														<td class = "board_hole_td"><div id="B5">A1</div></td>
													</tr>
												</table>
											</td>
											<td class="board_two_vert_holes">
												<table style="width:100%">
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="A6">A1</div></td>
													</tr>
													<tr class = "board_hole_row">
														<td class = "board_hole_td"><div id="B6">A1</div></td>
													</tr>
												</table>
											</td>																													
											<td class="board_hole_store"><div id="B_store">0</div></td>
										</tr>	
									</table>	
								</td>
							</tr>
							<tr>
								<td class="board_player_info" id="board_computer_legend">Computer</td>
							</tr>
						</table>
					</div>
				</div>				
			</div>
		</div>
	</div>
</body>

<script>
var computer_mode = 'pc_mode_minimax_L2' 
function pc_mode_selection(mode_selected){
	console.log(mode_selected)
	computer_mode = mode_selected
}
function Bord(){
	this.score = {"playerA": 0 , "playerB":0}
	
	this.field_names = ["A6", "A5", "A4", "A3", "A2", "A1", "A_store","B1", "B2", "B3", "B4", "B5", "B6", "B_store"]
	this.field_values = [4,4,4,4,4,4,0,4,4,4,4,4,4,0]
	
	this.player_to_move = "A"
	this.possible_moves = []
	this.last_stone_landed;
	this.next_computer_move;
}
Bord.prototype.find_possible_moves = function(){
	
	// Create an array with the possible moves
	this.possible_moves = this.field_names
	// Filter out the stores
	this.possible_moves = this.possible_moves.filter(function(field_name){
		return field_name.indexOf("store") == -1
	}, this)

	// Filter, the current player should be in the field name
	this.possible_moves = this.possible_moves.filter(function(field_name){
		return field_name.indexOf(this.player_to_move) != -1
	}, this)
	// Filter, the number of stones in the possible fields should be bigger than zero
	this.possible_moves = this.possible_moves.filter(function(field_name){
		field_position = this.field_names.indexOf(field_name)
		return this.field_values[field_position] > 0
	}, this)
}
Bord.prototype.visualize_possible_moves = function(){
	// Add a border and event listener around the ones that are possible
	this.field_names.forEach(function(field_name, field_position){
		css_name = "#" + field_name
		if(this.possible_moves.indexOf(field_name) != -1){
			$('body').off('click',css_name)
			$('body').on('click', css_name,  field_name, correct_button_clicked)
			$(css_name).css('background-color', 'lightblue')
		}else{
			$('body').off('click',css_name)
			$('body').on('click', css_name,field_name,  false_button_clicked)
			$(css_name).css('background-color', 'transparent')
		}
	}, this)
}
Bord.prototype.visualize_best_move_computer = function(){
	this.field_names.forEach(function(field_name, field_position){
		css_name = "#" + field_name
		if(this.next_computer_move == field_name){
			$('body').off('click',css_name)
			$('body').on('click', css_name,  field_name, correct_button_clicked)
			$(css_name).css('background-color', 'lightblue')
		}else{
			$('body').off('click',css_name)
			$('body').on('click', css_name,field_name,  false_button_clicked)
			$(css_name).css('background-color', 'transparent')
		}
	}, this)
}

function correct_button_clicked(click_event){
	field_name_clicked = click_event.data
	main_bord.move(field_name_clicked, "real")
}
function false_button_clicked(){
}
Bord.prototype.move = function(selected_field_code, real_move_or_tree_building){
	// Counter for the moves generated
	moves_generated += 1
	// Decode selected field to position
	selected_field_position = this.field_names.indexOf(selected_field_code)
	selected_field_value = this.field_values[selected_field_position]
	// How many stones does he pick up and distribute
	var stones_to_distribute = selected_field_value
	// Set initial selected fields to zero
	this.field_values[selected_field_position] = 0

	// Distribute the stones, i is the counter to loop over the holes
	var i = 1
	var stones_distributed = 0
	while (stones_distributed < stones_to_distribute) {
		// Look at next vield
		board_field_to_fill = selected_field_position + i;
		if(board_field_to_fill > 13)
	 		board_field_to_fill = board_field_to_fill - 14;
		// If it is a store, check if it is not the store of the opponent
		if(board_field_to_fill == 6 | board_field_to_fill == 13){
			if(this.field_names[board_field_to_fill].indexOf(this.player_to_move) == -1){
				// No stone is laid in the other hole, so don't substract a stone of the total stones to be distributed
				i++;
			}else{
				// Stone is laid in his own store
				this.field_values[board_field_to_fill] +=1 
				stones_distributed++;
				// Update the score by one, because the player scored by adding one to his store
				if(this.player_to_move == "A"){
				 	this.score["playerA"] += 1
				}else if(this.player_to_move == "B"){
				 	this.score["playerB"] += 1
				}			
				i++;
			}
		}else{
			//Normal hole
			this.field_values[board_field_to_fill] +=1 
			stones_distributed++;
			i++;
		}
	}

	// Remember after the loop where the last stone landed, this is important to calculate the scores
	this.last_stone_landed = this.field_names[board_field_to_fill]
	// Calculate scores
	this.remove_stones_conquered_and_update_score();
	
	if(real_move_or_tree_building == "real"){
		// Real move, so print everything and make board ready for next player
		this.print_to_html();
		this.set_next_player_to_move();
		this.find_possible_moves();
		//If possible moves array is empty, game is over
		if(this.possible_moves.length ==0){
			this.allocate_stones_to_stores_end_of_game();
			this.print_to_html()
				if(this.score.playerA > this.score.playerB){
					$("#board_human_legend").text('Player A won with ' + this.score.playerA + " seeds")
					$("#board_computer_legend").text('Player B lost with '+ this.score.playerB + " seeds")
				}else if(this.score.playerA < this.score.playerB){
					$("#board_computer_legend").text('Player B won with ' + this.score.playerB + " seeds")
					$("#board_human_legend").text('Player A lost with '+ this.score.playerA + " seeds")
				}else if(this.score.playerA == this.score.playerB){
					$("#board_computer_legend").text('Draw')
					$("#board_human_legend").text('Draw')
					return
				}			
		}
		// If it is the computer, computer move, otherwise prepare board for human
		if(this.player_to_move == 'B'){
			//Computer move, is random mode selected?
			if(computer_mode == 'pc_mode_random'){
				// Generate random computer move
				this.next_computer_move = this.possible_moves[Math.floor(Math.random()*this.possible_moves.length)];
			}else if(computer_mode == 'pc_mode_minimax_L1'){
				// Minimax, so call function minimax that gives back best move
				this.next_computer_move = this.find_mini_max_move(2)
			}else if(computer_mode == 'pc_mode_minimax_L2'){
				// Minimax, so call function minimax that gives back best move
				this.next_computer_move = this.find_mini_max_move(4)
			}else if(computer_mode == 'pc_mode_minimax_L3'){
				// Minimax, so call function minimax that gives back best move
				this.next_computer_move = this.find_mini_max_move(6)
			}
			this.visualize_best_move_computer();
		}else{
			// Human player, highlight his options	
			this.visualize_possible_moves();
		}
	}else if(real_move_or_tree_building == "tree_building"){
		this.set_next_player_to_move();
		this.find_possible_moves();
		if(this.possible_moves.length ==0){
			//End of game
			this.allocate_stones_to_stores_end_of_game();	
		}
	}
}

Bord.prototype.allocate_stones_to_stores_end_of_game = function(){
	console.log('Inside end of game')
	var fields_to_allocate = this.field_names
	// Filter, not the stores
	fields_to_allocate = fields_to_allocate.filter(function(field_name){
		if(field_name.indexOf("store") == -1) return true
	},this)
	// Loop over the fields, give stones to the store of correct player and update the scores
	for(var i=0; i<fields_to_allocate.length;i++){
		// Field of player A or B?
		if(fields_to_allocate[i].indexOf("A") != -1){
			// Field of player A
			// Find position
			temp_position = this.field_names.indexOf(fields_to_allocate[i])
			// Update store and score
			this.field_values[6] += this.field_values[temp_position]
			this.score.playerA +=  this.field_values[temp_position]
			// Set stones to zero
			this.field_values[temp_position] = 0
		}else if(fields_to_allocate[i].indexOf("B") != -1){
			// Field of player B
			// Find position
			temp_position = this.field_names.indexOf(fields_to_allocate[i])
			// Update store and score
			this.field_values[13] += this.field_values[temp_position]
			this.score.playerB +=  this.field_values[temp_position]
			// Set stones to zero
			this.field_values[temp_position] = 0
		}
	}
}

Bord.prototype.build_X_level_moves = function(X_levels){
	// He already knows the next possible moves, which one should he pick?
	var score_tree = {}
	// If there are no moves left, the current score is the best one
	var best_score = this.score['playerB'] - this.score['playerA']
	var best_move;

	if(this.possible_moves.length == 0) console.log('He is at a dead end of player B')
	// Level 1: simulate through all the options of the computer
	for(var i = 0; i < this.possible_moves.length; i++){
		score_tree[this.possible_moves[i]] = {}
		// 
		var virtual_bord = jQuery.extend(true, {}, this)
		// Move generation
		virtual_bord.move(virtual_bord.possible_moves[i], "tree_building")
		// Register score
		var temp_score = virtual_bord.score['playerB']-virtual_bord.score['playerA']
		score_tree[this.possible_moves[i]]['score'] = temp_score
		// Level 2: for each option of computer, calculate scores of other player, is stored in another score tree
		// If there are no other moves left, the current score is also the minimizing score
		var temp_score_tree = {}
		var temp_minimizing_score = temp_score
		if( virtual_bord.possible_moves.length == 0) console.log('He is at a dead end of player A')
		for(var j=0; j < virtual_bord.possible_moves.length; j++){
			// Create another virtual copy
			var virtual_bord_L2 = jQuery.extend(true, {}, virtual_bord)
			// Player A is playing again, so switch player
			virtual_bord_L2.player_to_move = "A"
			// Move generation
			virtual_bord_L2.move(virtual_bord.possible_moves[j], "tree_building")
			// Keep track of score
			if(X_levels == 2){
				// Score is now just the difference between the scores of the two players
				var temp_score = virtual_bord_L2.score['playerB']-virtual_bord_L2.score['playerA']
				// Store in uniform object X_level_moves
				temp_score_tree[virtual_bord.possible_moves[j]] = {}
				temp_score_tree[virtual_bord.possible_moves[j]]['best_score'] = temp_score
			}else if(X_levels ==4){
				// He needs to generate again a 2 level tree, recursive
				temp_score_tree[virtual_bord.possible_moves[j]] = virtual_bord_L2.build_X_level_moves(2)
			}else if(X_levels == 6){
				// He needs to generate again a 2 level tree, recursive
				temp_score_tree[virtual_bord.possible_moves[j]] = virtual_bord_L2.build_X_level_moves(4)				
			}
			// Keep track of best score, Assuming player A goes for Minimizing
			if(j==0) {
				temp_minimizing_score = temp_score_tree[virtual_bord.possible_moves[j]]['best_score']
			}else{
				temp_minimizing_score = Math.min(temp_minimizing_score, temp_score_tree[virtual_bord.possible_moves[j]]['best_score'])
			}
		}

		score_tree[this.possible_moves[i]]['score_tree'] = temp_score_tree
		score_tree[this.possible_moves[i]]['minimizing_score'] = temp_minimizing_score

		// Keep track of best score, When player B is maximizing
		if(i==0){
			best_move = this.possible_moves[0]
			best_score = temp_minimizing_score
		}else{
			if(temp_minimizing_score > best_score){
				best_score = temp_minimizing_score
				best_move = this.possible_moves[i]
			}
		}
	}

	// Resultaat goed formatten en returnen
	var X_level_moves = {}
	X_level_moves['best_move'] = best_move
	X_level_moves['best_score'] = best_score
	X_level_moves['score_tree'] = score_tree
	return X_level_moves
}

var moves_generated;
// Should get an argument levels deep
Bord.prototype.find_mini_max_move = function(levels){
	moves_generated = 0;
	//console.log('Beginning of find mini max, with levels: ' + levels)
	X_level_moves = this.build_X_level_moves(levels)
	//console.log('X_level moves: ')
	//console.log(X_level_moves)
	best_move = X_level_moves['best_move']
	console.log('Moves generated: ' + moves_generated)
	return best_move
}



Bord.prototype.remove_stones_conquered_and_update_score = function(){
	
	// First check, the last stone must be landed in the other player his array
	if(this.last_stone_landed.indexOf(this.player_to_move) != -1) return
	
	// Second check, the last stone landed must be the only stone in that field
	var last_stone_position = this.field_names.indexOf(this.last_stone_landed)
	if(this.field_values[last_stone_position] != 1) return

	// Last check, is it in a score?
	if(last_stone_position == 6 | last_stone_position == 13) return

	// All the checks passed, so Score!
	// Find the correct position to take stones of, take the stones and update the scores,
	// With filter mechanism, filter row current player, filter nummer of last stone landed (i.e.: A3 -> B3)
	field_captured_code = this.field_names
	field_captured_code = field_captured_code.filter(function(field_code, field_position){
		return field_code.indexOf(this.player_to_move) > -1
	}, this)
	field_captured_code = field_captured_code.filter(function(field_code, field_position){
		return field_code.indexOf(this.last_stone_landed[1]) > -1
	}, this)
	field_captured_code = field_captured_code[0]
	field_captured_position = this.field_names.indexOf(field_captured_code)
	// Update scores, one extra point for the last stone!
	if(this.player_to_move == "A"){
	 	this.score["playerA"] += this.field_values[field_captured_position] + 1
	 	this.field_values[6] += this.field_values[field_captured_position] + 1
	}else if(this.player_to_move == "B"){
	 	this.score["playerB"] += this.field_values[field_captured_position] + 1
	 	this.field_values[13] += this.field_values[field_captured_position] + 1
	}
	// Empty field 
	this.field_values[field_captured_position] = 0
	// Empty the field of the last stone
	this.field_values[last_stone_position] = 0
}
Bord.prototype.set_next_player_to_move = function(){
	if(this.player_to_move == "A"){
		this.player_to_move = "B"
	}else if(this.player_to_move == "B"){
	 	this.player_to_move = "A"
	}
}
Bord.prototype.print_to_html = function(){
	$("#A1").text(this.field_values[5])
	$("#A2").text(this.field_values[4])
	$("#A3").text(this.field_values[3])
	$("#A4").text(this.field_values[2])
	$("#A5").text(this.field_values[1])
	$("#A6").text(this.field_values[0])
	$("#B1").text(this.field_values[7])
	$("#B2").text(this.field_values[8])
	$("#B3").text(this.field_values[9])
	$("#B4").text(this.field_values[10])
	$("#B5").text(this.field_values[11])
	$("#B6").text(this.field_values[12])

	$("#A_store").text(this.field_values[6])
	$("#B_store").text(this.field_values[13])

	$("#board_human_legend").text("Score human: " + this.score['playerA'])
	$("#board_computer_legend").text("Score computer: " + this.score['playerB'])
}
main_bord = new Bord();
main_bord.print_to_html();
main_bord.find_possible_moves();
main_bord.visualize_possible_moves();






</script>





</body>
</html>
